(#Y(si::bytecodes nil nil (1 0 16 1 29) #1=#A(t (260) ("COMPILE-SIMPLIFY" si::select-package compile-simplify::expp ext::location (defun compile-simplify::expp) (#2=#P"/data/data/org.eql5.android.repl/files/quicklisp/local-projects/paip/ch-09b.lisp" . 210) ext::annotate :lambda-list (symbolic::x) symbolic::x consp #Y(compile-simplify::expp nil nil (24 48 9 26 11 9 16 10 44 1 29) #1# #2# 210) si::fset compile-simplify::make-exp (defun compile-simplify::make-exp) (#2# . 240) (compile-simplify::lhs compile-simplify::op &optional compile-simplify::rhs) compile-simplify::lhs compile-simplify::op compile-simplify::rhs #Y(compile-simplify::make-exp nil nil (24 45 17 24 45 18 25 40 2 77 46 19 26 10 0 39 12 13 1 13 2 10 0 6 3 73 38 8 13 1 10 2 6 2 73 29) #1# #2# 240) compile-simplify::exp-lhs (defun compile-simplify::exp-lhs) (#2# . 336) (exp) exp second #Y(compile-simplify::exp-lhs nil nil (24 45 25 26 10 0 16 26 29) #1# #2# 336) compile-simplify::exp-rhs (defun compile-simplify::exp-rhs) (#2# . 374) (exp) third #Y(compile-simplify::exp-rhs nil nil (24 45 25 26 10 0 16 32 29) #1# #2# 374) compile-simplify::exp-op (defun compile-simplify::exp-op) (#2# . 411) (exp) #Y(compile-simplify::exp-op nil nil (24 45 25 26 10 0 4 73 29) #1# #2# 411) compile-simplify::variablep (defun compile-simplify::variablep) (#2# . 447) (symbolic::x) (symbolic::x symbolic::y compile-simplify::z compile-simplify::m compile-simplify::n compile-simplify::o compile-simplify::p compile-simplify::q compile-simplify::r compile-simplify::s t compile-simplify::u compile-simplify::v compile-simplify::w) member #Y(compile-simplify::variablep nil nil (24 48 9 26 14 9 15 43 19 2 44 44 1 29) #1# #2# 447) compile-simplify::*bindings* si::*make-special boundp variable "A list of bindings used by the
  rule compiler." si::set-documentation (defvar compile-simplify::*bindings*) (#2# . 518) compile-simplify::compile-rule (defun compile-simplify::compile-rule) (#2# . 595) (compile-simplify::rule) compile-simplify::rule function lambda (symbolic::x) :function compile-simplify::build-exp #Y(nil nil nil (26 13 0 19 1 28 12 14 46 19 2 63 29) #1# #2# 595) efficiency::make-delay compile-simplify::compile-exp #Y(compile-simplify::compile-rule nil nil (24 45 58 26 75 48 46 15 59 15 60 15 61 15 9 13 0 19 1 21 12 14 62 34 64 12 19 2 65 12 19 3 66 6 3 6 2 73 44 1 29) #1# #2# 595) "Compile a single rule." (defun compile-simplify::compile-exp) (#2# . 910) (compile-simplify::var compile-simplify::pattern compile-simplify::consequent) compile-simplify::var compile-simplify::pattern compile-simplify::consequent tools::get-binding when equal eliza::lookup efficiency::force atom eql quote compile-simplify::?is general-problem-solver::starts-with compile-simplify::op? compile-simplify::compile-args #Y(compile-simplify::compile-exp nil nil (24 45 72 24 45 73 24 45 74 26 13 1 14 46 19 2 75 39 27 15 76 15 77 13 2 13 1 14 46 19 2 78 6 3 12 13 0 19 1 79 6 3 73 38 132 13 1 19 1 39 39 19 13 1 10 2 3 12 11 46 3 52 46 13 0 19 1 79 38 107 10 1 16 80 39 26 15 76 15 81 13 2 15 82 10 1 6 2 6 3 12 13 0 19 1 79 6 3 73 38 76 13 1 15 83 19 2 84 39 37 10 1 16 26 12 10 2 3 12 11 46 3 52 46 15 76 10 1 16 32 12 10 2 6 2 12 13 0 19 1 79 6 3 73 38 31 15 76 15 85 13 2 15 82 13 1 19 1 34 6 2 6 3 12 13 2 13 1 13 0 19 3 86 6 3 73 29) #1# #2# 910) "Compile code that tests the expression,
  and performs the consequent if the
  expression matches the pattern.
  Assumes that *bindings* contains
  the appropriate bindings." (defun compile-simplify::compile-args) (#2# . 2168) (compile-simplify::var compile-simplify::pattern compile-simplify::consequent) compile-simplify::l compile-simplify::concat-symbol compile-simplify::r let #Y(nil nil nil (26 13 1 13 3 19 1 28 12 13 2 19 3 66 29) #1# #2# 2168) #Y(compile-simplify::compile-args nil nil (24 45 72 24 45 73 24 45 74 26 13 2 15 92 19 2 93 12 13 2 15 94 19 2 93 12 46 94 46 92 13 3 19 1 28 39 52 15 95 13 0 15 21 10 4 6 2 6 2 12 13 1 15 28 10 4 6 2 6 2 6 2 12 13 0 13 3 19 1 21 12 14 62 34 96 12 19 2 65 12 19 3 66 6 3 73 38 32 15 95 13 0 15 21 10 4 6 2 6 2 6 1 12 13 0 13 3 19 1 21 12 13 2 19 3 66 6 3 73 43 2 29) #1# #2# 2168) "Compile code that checks the arg or 
  args, and performs the consequent if 
  the args match." (defun compile-simplify::build-exp) (#2# . 2933) (exp compile-simplify::bindings) compile-simplify::bindings assoc "Variable ~A occurred on ~%~
      right hand side but not left~%~
      BUILD-EXP." error #Y(nil nil nil (24 48 9 26 14 9 13 0 19 2 63 44 1 29) #1# #2# 2933) mapcar compile-simplify::new-exp compile-simplify::simplify-exp list #Y(compile-simplify::build-exp nil nil (24 45 25 24 45 102 26 13 1 13 0 19 2 103 39 12 13 1 13 0 19 2 103 5 73 38 55 13 1 19 1 39 39 10 15 104 13 1 19 2 105 38 39 10 1 16 80 39 10 15 82 10 1 6 2 73 38 24 34 106 12 13 1 19 2 107 45 108 15 109 15 110 10 0 7 2 6 2 73 43 1 29) #1# #2# 2933) "Compile code that will build the exp,
  given the bindings." (defun compile-simplify::op?) (#2# . 3432) (exp compile-simplify::op) eq #Y(compile-simplify::op? nil nil (24 45 25 24 45 18 26 13 1 19 1 2 73 39 11 13 1 19 1 34 12 10 0 17 116 29) #1# #2# 3432) "Does the expression have the given op
  as its operator?" (defun compile-simplify::concat-symbol) (#2# . 3561) (&rest compile-simplify::args) compile-simplify::args "~{~A~}" format intern #Y(compile-simplify::concat-symbol nil nil (27 45 122 77 15 123 13 0 19 3 124 12 19 1 125 29) #1# #2# 3561) "Concatenate symbols or strings to
  form an interned symbol." compile-simplify::new-symbol (defun compile-simplify::new-symbol) (#2# . 3705) (&rest compile-simplify::args) "~{~A~}" make-symbol #Y(compile-simplify::new-symbol nil nil (27 45 122 77 15 132 13 0 19 3 124 16 133 29) #1# #2# 3705) "Concatenate symbols or strings to
  form an uninterned symbol." compile-simplify::n compile-simplify::m compile-simplify::s symbolic::clear-props (compile-simplify::?is compile-simplify::n numberp) tools::pat-match-abbrev (compile-simplify::?is compile-simplify::m numberp) (compile-simplify::?is compile-simplify::s symbolic::not-number-p) compile-simplify::compile-rule-set (defun compile-simplify::compile-rule-set) (#2# . 4059) (compile-simplify::op) (symbolic::x) compile-simplify::combine-rules compile-simplify::compile-indexed-rule efficient-simplify::rules-for reduce compile symbolic::set-simp-fn #Y(compile-simplify::compile-rule-set nil nil (24 45 18 26 13 0 77 15 60 15 148 33 149 12 33 150 12 13 0 19 1 151 12 19 2 107 12 19 2 152 6 3 12 19 2 153 12 19 2 154 29) #1# #2# 4059) "Compile all rules indexed under a given
  main op, and make them into the simp-fn
  for that op." (defun compile-simplify::compile-indexed-rule) (#2# . 4441) (compile-simplify::rule) #Y(nil nil nil (26 13 0 19 1 28 12 14 46 19 2 63 29) #1# #2# 4441) #Y(compile-simplify::compile-indexed-rule nil nil (24 45 58 26 75 48 46 15 9 13 0 19 1 21 12 14 62 34 160 12 19 2 65 12 19 3 86 44 1 29) #1# #2# 4441) "Compile one rule into lambda-less
  code, assuming indexing of main op." (defun compile-simplify::combine-rules) (#2# . 4703) (compile-simplify::a compile-simplify::b) compile-simplify::a compile-simplify::b listp length = compile-simplify::matching-ifs if fourth or compile-simplify::last1 butlast append #Y(compile-simplify::combine-rules nil nil (24 45 166 24 45 167 26 10 1 16 168 39 46 10 0 16 168 39 40 10 1 16 169 12 10 0 16 169 12 9 3 19 3 170 39 23 10 1 4 12 10 0 4 17 77 39 12 10 1 16 26 12 10 0 16 26 17 77 39 28 10 1 4 12 10 1 16 26 12 10 1 16 32 12 10 0 16 32 12 19 2 149 6 3 73 38 117 13 1 13 0 19 2 171 39 40 15 172 10 1 16 26 12 10 1 16 32 12 10 0 16 32 12 19 2 149 12 10 1 16 173 12 10 0 16 173 12 19 2 149 6 4 73 38 69 13 1 15 174 19 2 84 39 51 13 1 19 1 175 12 13 0 19 2 171 39 26 13 1 19 1 176 12 13 1 19 1 175 12 13 0 19 2 149 6 1 12 19 2 177 38 11 13 1 10 0 6 1 12 19 2 177 38 10 15 174 13 1 10 0 6 3 73 29) #1# #2# 4703) "Combine the code for two rules into
  one, maintaining order." (defun compile-simplify::matching-ifs) (#2# . 5852) (compile-simplify::a compile-simplify::b) (if when) (if when) #Y(compile-simplify::matching-ifs nil nil (24 45 166 24 45 167 26 10 1 16 10 73 39 43 10 1 4 12 15 183 19 2 44 73 39 31 10 0 16 10 73 39 24 10 0 4 12 15 184 19 2 44 73 39 12 10 1 16 26 12 10 0 16 26 17 77 29) #1# #2# 5852) "Are a and b IF statements with the 
  same predicate?" (defun compile-simplify::last1) (#2# . 6106) (list) last #Y(compile-simplify::last1 nil nil (24 45 110 26 13 0 19 1 190 4 73 29) #1# #2# 6106) "Return the last element of a list" compile-simplify::compile-all-rules-indexed (defun compile-simplify::compile-all-rules-indexed) (#2# . 6193) (compile-simplify::rules) compile-simplify::rules efficient-simplify::index-rules efficient-simplify::main-op delete-duplicates compile-simplify::all-ops mapc #Y(compile-simplify::compile-all-rules-indexed nil nil (24 45 197 26 13 0 19 1 198 33 199 12 13 0 19 2 107 12 19 1 200 45 201 33 144 12 13 0 19 2 202 43 1 29) #1# #2# 6193) "Compile a separate fn for each operator,
  and store it as the simp-fn of the 
  operator." symbolic::*simplification-rules* (defun compile-simplify::simplify-exp) (#2# . 6563) (exp) symbolic::simplify-by-fn symbolic::evaluable eval #Y(compile-simplify::simplify-exp nil nil (24 45 25 26 13 0 19 1 209 73 40 17 13 0 19 1 210 39 7 10 0 16 211 38 4 10 0 73 29) #1# #2# 6563) "Simplify by doing arithmetic, or 
  by using the simp-fn for this 
  operator. Do not use rules of 
  any kind." compile-simplify::simplify (defun compile-simplify::simplify) (#2# . 6847) (exp) #Y(compile-simplify::simplify nil nil (24 45 25 26 10 0 16 80 39 6 10 0 73 38 13 33 214 12 13 0 19 2 107 12 19 1 109 29) #1# #2# 6847) "Simplify an expression by first 
  simplifying its components." compile-simplify::*test-data* symbolic::infix->prefix ((symbolic::d (compile-simplify::a * symbolic::x symbolic::^ 2 + compile-simplify::b * symbolic::x + compile-simplify::c) / symbolic::d symbolic::x) (symbolic::d ((compile-simplify::a * symbolic::x symbolic::^ 2 + compile-simplify::b * symbolic::x + compile-simplify::c) / symbolic::x) / symbolic::d symbolic::x) (symbolic::d ((compile-simplify::a * symbolic::x symbolic::^ 3 + compile-simplify::b * symbolic::x symbolic::^ 2 + compile-simplify::c * symbolic::x + symbolic::d) / symbolic::x symbolic::^ 5) / symbolic::d symbolic::x) ((sin (symbolic::x + symbolic::x)) * (sin (2 * symbolic::x)) + (cos (symbolic::d (symbolic::x symbolic::^ 2) / symbolic::d symbolic::x)) symbolic::^ 1) (symbolic::d (3 * symbolic::x + (cos symbolic::x) / symbolic::x) / symbolic::d symbolic::x)) (defvar compile-simplify::*test-data*) (#2# . 7061) compile-simplify::*answers* symbolic::simplify (defvar compile-simplify::*answers*) (#2# . 7421) compile-simplify::test-it (defun compile-simplify::test-it) (#2# . 7484) (&optional (efficiency::with-profiling t)) t efficiency::with-profiling efficiency::unprofile1 #3=(compile-simplify::simplify compile-simplify::simplify-exp compile-simplify::variablep tools::match-variable tools::pat-match) efficiency::*profiled-functions* (quote #3#) set-difference efficiency::profile1 union efficiency::*profile-call-stack* efficiency::profile-report compile-simplify::answers compile-simplify::assert-equal #Y(compile-simplify::test-it nil nil (25 40 3 14 233 46 234 26 10 0 39 73 33 235 12 15 236 19 2 107 14 237 15 238 19 2 239 52 237 33 240 12 14 237 15 236 19 2 241 52 237 12 19 2 107 75 52 242 64 10 33 214 12 14 220 19 2 107 65 15 236 19 1 243 33 235 12 15 236 19 2 107 14 237 15 238 19 2 239 52 237 66 38 9 33 214 12 14 220 19 2 107 45 244 33 245 12 13 0 14 225 19 3 202 11 233 73 43 1 29) #1# #2# 7484) "Time a test run and make sure the 
  answers are correct." (defun compile-simplify::assert-equal) (#2# . 8018) (symbolic::x symbolic::y) symbolic::y (equal symbolic::x symbolic::y) (symbolic::x symbolic::y) "Expected ~A to be equal to ~A" si::assert-failure #:g727 #:g728 #Y(compile-simplify::assert-equal nil nil (24 48 9 24 48 251 26 38 37 15 252 15 253 14 9 11 251 6 2 12 15 254 14 9 14 251 19 6 255 47 1 256 45 257 10 0 52 9 10 1 52 251 43 2 75 14 9 11 251 17 77 76 40 -44 73 44 2 29) #1# #2# 8018) "If x is not equal to y, complain.")) #2# 0) #Y(si::bytecodes nil nil (15 2 15 3 15 4 15 5 19 4 6 15 2 14 7 77 15 8 19 4 6 15 2 1 11 12 19 2 12 1 2 73 29) #1# #2# 210) #Y(si::bytecodes nil nil (15 13 15 3 15 14 15 15 19 4 6 15 13 14 7 77 15 16 19 4 6 15 13 1 20 12 19 2 12 1 13 73 29) #1# #2# 240) #Y(si::bytecodes nil nil (15 21 15 3 15 22 15 23 19 4 6 15 21 14 7 77 15 24 19 4 6 15 21 1 27 12 19 2 12 1 21 73 29) #1# #2# 336) #Y(si::bytecodes nil nil (15 28 15 3 15 29 15 30 19 4 6 15 28 14 7 77 15 31 19 4 6 15 28 1 33 12 19 2 12 1 28 73 29) #1# #2# 374) #Y(si::bytecodes nil nil (15 34 15 3 15 35 15 36 19 4 6 15 34 14 7 77 15 37 19 4 6 15 34 1 38 12 19 2 12 1 34 73 29) #1# #2# 411) #Y(si::bytecodes nil nil (15 39 15 3 15 40 15 41 19 4 6 15 39 14 7 77 15 42 19 4 6 15 39 1 45 12 19 2 12 1 39 73 29) #1# #2# 447) #Y(si::bytecodes nil nil (1 46 16 47 1 46 16 48 76 39 4 75 52 46 15 46 15 49 15 50 19 3 51 15 46 15 3 15 52 15 53 19 4 6 1 46 73 29) #1# #2# 518) #Y(si::bytecodes nil nil (15 54 15 3 15 55 15 56 19 4 6 15 54 14 7 77 15 57 19 4 6 15 54 34 67 12 19 2 12 15 54 15 59 15 68 19 3 51 1 54 73 29) #1# #2# 595) #Y(si::bytecodes nil nil (15 66 15 3 15 69 15 70 19 4 6 15 66 14 7 77 15 71 19 4 6 15 66 1 87 12 19 2 12 15 66 15 59 15 88 19 3 51 1 66 73 29) #1# #2# 910) #Y(si::bytecodes nil nil (15 86 15 3 15 89 15 90 19 4 6 15 86 14 7 77 15 91 19 4 6 15 86 34 97 12 19 2 12 15 86 15 59 15 98 19 3 51 1 86 73 29) #1# #2# 2168) #Y(si::bytecodes nil nil (15 63 15 3 15 99 15 100 19 4 6 15 63 14 7 77 15 101 19 4 6 15 63 34 111 12 19 2 12 15 63 15 59 15 112 19 3 51 1 63 73 29) #1# #2# 2933) #Y(si::bytecodes nil nil (15 85 15 3 15 113 15 114 19 4 6 15 85 14 7 77 15 115 19 4 6 15 85 1 117 12 19 2 12 15 85 15 59 15 118 19 3 51 1 85 73 29) #1# #2# 3432) #Y(si::bytecodes nil nil (15 93 15 3 15 119 15 120 19 4 6 15 93 14 7 77 15 121 19 4 6 15 93 1 126 12 19 2 12 15 93 15 59 15 127 19 3 51 1 93 73 29) #1# #2# 3561) #Y(si::bytecodes nil nil (15 128 15 3 15 129 15 130 19 4 6 15 128 14 7 77 15 131 19 4 6 15 128 1 134 12 19 2 12 15 128 15 59 15 135 19 3 51 1 128 73 29) #1# #2# 3705) #Y(si::bytecodes nil nil (15 136 15 137 15 138 19 3 139 29) #1# #2# 3910) #Y(si::bytecodes nil nil (15 136 15 140 19 2 141 29) #1# #2# 3934) #Y(si::bytecodes nil nil (15 137 15 142 19 2 141 29) #1# #2# 3974) #Y(si::bytecodes nil nil (15 138 15 143 19 2 141 29) #1# #2# 4014) #Y(si::bytecodes nil nil (15 144 15 3 15 145 15 146 19 4 6 15 144 14 7 77 15 147 19 4 6 15 144 1 155 12 19 2 12 15 144 15 59 15 156 19 3 51 1 144 73 29) #1# #2# 4059) #Y(si::bytecodes nil nil (15 150 15 3 15 157 15 158 19 4 6 15 150 14 7 77 15 159 19 4 6 15 150 34 161 12 19 2 12 15 150 15 59 15 162 19 3 51 1 150 73 29) #1# #2# 4441) #Y(si::bytecodes nil nil (15 149 15 3 15 163 15 164 19 4 6 15 149 14 7 77 15 165 19 4 6 15 149 1 178 12 19 2 12 15 149 15 59 15 179 19 3 51 1 149 73 29) #1# #2# 4703) #Y(si::bytecodes nil nil (15 171 15 3 15 180 15 181 19 4 6 15 171 14 7 77 15 182 19 4 6 15 171 1 185 12 19 2 12 15 171 15 59 15 186 19 3 51 1 171 73 29) #1# #2# 5852) #Y(si::bytecodes nil nil (15 175 15 3 15 187 15 188 19 4 6 15 175 14 7 77 15 189 19 4 6 15 175 1 191 12 19 2 12 15 175 15 59 15 192 19 3 51 1 175 73 29) #1# #2# 6106) #Y(si::bytecodes nil nil (15 193 15 3 15 194 15 195 19 4 6 15 193 14 7 77 15 196 19 4 6 15 193 1 203 12 19 2 12 15 193 15 59 15 204 19 3 51 1 193 73 29) #1# #2# 6193) #Y(si::bytecodes nil nil (14 205 19 1 193 29) #1# #2# 6475) #Y(si::bytecodes nil nil (15 109 15 3 15 206 15 207 19 4 6 15 109 14 7 77 15 208 19 4 6 15 109 1 212 12 19 2 12 15 109 15 59 15 213 19 3 51 1 109 73 29) #1# #2# 6563) #Y(si::bytecodes nil nil (15 214 15 3 15 215 15 216 19 4 6 15 214 14 7 77 15 217 19 4 6 15 214 1 218 12 19 2 12 15 214 15 59 15 219 19 3 51 1 214 73 29) #1# #2# 6847) #Y(si::bytecodes nil nil (1 220 16 47 1 220 16 48 76 39 11 33 221 12 15 222 19 2 107 52 220 15 220 15 3 15 223 15 224 19 4 6 1 220 73 29) #1# #2# 7061) #Y(si::bytecodes nil nil (1 225 16 47 1 225 16 48 76 39 11 33 226 12 14 220 19 2 107 52 225 15 225 15 3 15 227 15 228 19 4 6 1 225 73 29) #1# #2# 7421) #Y(si::bytecodes nil nil (15 229 15 3 15 230 15 231 19 4 6 15 229 14 7 77 15 232 19 4 6 15 229 1 246 12 19 2 12 15 229 15 59 15 247 19 3 51 1 229 73 29) #1# #2# 7484) #Y(si::bytecodes nil nil (15 245 15 3 15 248 15 249 19 4 6 15 245 14 7 77 15 250 19 4 6 15 245 1 258 12 19 2 12 15 245 15 59 15 259 19 3 51 1 245 73 29) #1# #2# 8018))
