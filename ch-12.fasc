(#Y(si::bytecodes nil nil (1 0 16 1 29) #1=#A(t (467) ("COMPILE-LOGIC" si::select-package compile-logic::prolog-compile ext::location (defun compile-logic::prolog-compile) (#2=#P"/data/data/org.eql5.android.repl/files/quicklisp/local-projects/paip/ch-12.lisp" . 93) ext::annotate :lambda-list (symbol &optional (compile-logic::compilep t) (compile-logic::clauses (logic::get-clauses symbol))) symbol t compile-logic::compilep logic::get-clauses compile-logic::clauses logic::clause-head compile-logic::relation-arity compile-logic::arity = compile-logic::clauses-with-arity compile-logic::compile-predicate print /= compile-logic::cl-without-ar #Y(compile-logic::prolog-compile nil nil (24 45 9 25 40 3 14 10 46 11 25 40 7 13 1 19 1 12 12 46 13 26 10 0 76 76 73 39 82 10 0 4 12 19 1 14 12 19 1 15 45 16 13 3 13 0 13 2 13 1 33 17 12 13 0 19 3 18 12 19 4 19 12 19 1 20 13 1 33 21 12 13 0 19 3 18 45 22 10 0 39 16 13 4 13 3 13 0 19 3 2 12 19 1 20 38 10 13 4 13 3 13 0 19 3 2 43 1 43 1 29) #1# #2# 93) si::fset function "Compile a symbol; make a separate function
  for each arity." si::set-documentation (defun compile-logic::clauses-with-arity) (#2# . 1501) (compile-logic::clauses compile-logic::test compile-logic::arity) compile-logic::test :key compile-logic::clause #Y(nil nil nil (24 45 33 26 13 0 19 1 14 12 19 1 15 29) #1# #2# 1501) :test general-problem-solver::find-all #Y(compile-logic::clauses-with-arity nil nil (24 45 13 24 45 31 24 45 16 26 13 0 13 2 14 32 1 34 12 14 35 13 1 19 6 36 29) #1# #2# 1501) "Return all clauses whose head has given 
  arity." (defun compile-logic::relation-arity) (#2# . 1749) (compile-logic::relation) compile-logic::relation compile-logic::args length #Y(compile-logic::relation-arity nil nil (24 45 42 26 13 0 19 1 43 16 44 29) #1# #2# 1749) "The number of arguments to a relation." (defun compile-logic::args) (#2# . 1854) (compile-logic::x) compile-logic::x #Y(compile-logic::args nil nil (24 45 50 26 10 0 5 73 29) #1# #2# 1854) "The arguments of a relation" compile-logic::compile-predicate% (defun compile-logic::compile-predicate%) (#2# . 1915) (symbol compile-logic::arity compile-logic::clauses) compile-logic::make-predicate compile-logic::make-parameters compile-logic::parameters logic::predicate defun (compile-logic::cont) append compile-logic::cont compile-logic::compile-clause #Y(nil nil nil (24 45 33 26 13 2 13 0 15 64 19 3 65 29) #1# #2# 1915) mapcar eval compile #Y(compile-logic::compile-predicate% nil nil (24 45 9 24 45 16 24 45 13 26 13 2 13 1 19 2 57 12 13 1 19 1 58 12 46 59 46 60 15 61 13 0 13 1 15 62 19 2 63 12 34 66 12 13 2 19 2 67 7 4 16 68 12 19 1 69 43 2 29) #1# #2# 1915) "Compile all the clauses for a given
  symbol/arity into a single function." (defun compile-logic::make-parameters) (#2# . 2454) (compile-logic::arity) #:loop-limit1105 compile-logic::i #:loop-list-head1106 #:loop-list-tail1107 0 > compile-logic::?arg compile-simplify::new-symbol rplacd 1+ #Y(compile-logic::make-parameters nil nil (24 45 16 26 58 60 73 9 1 13 1 46 75 46 76 75 6 1 45 77 10 0 45 78 57 79 61 2 2 37 13 3 13 4 19 2 80 39 4 35 0 1 13 1 15 81 13 3 19 2 82 6 1 51 1 17 83 10 3 16 84 51 3 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 29) #1# #2# 2454) "Return the list (?arg, ?arg2, ..., ?argn)
  for arity." (defun compile-logic::make-predicate) (#2# . 2614) (symbol compile-logic::arity) / compile-simplify::concat-symbol #Y(compile-logic::make-predicate nil nil (24 45 9 24 45 16 26 13 1 15 90 13 0 19 3 91 29) #1# #2# 2614) "Return the symbol <symbol>/<arity>" compile-logic::compile-clause% (defun compile-logic::compile-clause%) (#2# . 2726) (compile-logic::parms compile-logic::clause compile-logic::cont) compile-logic::parms compile-logic::make-= logic::clause-body nconc compile-logic::compile-body #Y(compile-logic::compile-clause% nil nil (24 45 98 24 45 33 24 45 64 26 33 99 12 13 2 13 1 19 1 14 12 19 1 43 12 19 3 67 12 13 1 19 1 100 12 19 2 101 12 13 0 19 2 102 29) #1# #2# 2726) "Transform away the head, and compile
  the resulting body." (defun compile-logic::make-=) (#2# . 3209) (compile-logic::x compile-logic::y) compile-logic::y #Y(compile-logic::make-= nil nil (24 45 50 24 45 108 26 15 17 13 1 10 0 6 3 73 29) #1# #2# 3209) (defun compile-logic::compile-body) (#2# . 3248) (compile-logic::body compile-logic::cont) compile-logic::body funcall compile-logic::goal compile-logic::prolog-compiler-macro compile-logic::macro compile-logic::macro-val :pass equal compile-logic::arg compile-logic::compile-arg #Y(nil nil nil (24 45 121 26 13 0 19 1 122 29) #1# #2# 3248) lambda compile-logic::compile-call #Y(compile-logic::compile-body nil nil (24 45 113 24 45 64 26 10 1 76 39 10 15 114 10 0 6 2 73 38 119 10 1 4 45 115 13 0 19 1 60 12 19 1 116 45 117 10 0 39 14 13 0 13 1 10 3 5 12 13 2 20 3 23 45 118 10 1 39 8 13 0 11 119 17 120 76 39 6 10 0 73 38 64 13 2 19 1 60 12 13 2 19 1 15 12 19 2 57 12 1 123 12 13 2 19 1 43 12 19 2 67 12 10 4 5 76 39 6 10 3 73 38 20 15 25 15 124 77 10 4 5 12 13 3 19 2 102 6 3 6 2 73 12 19 3 125 43 3 29) #1# #2# 3248) "Compile the body of a clause." (defun compile-logic::compile-call) (#2# . 4286) (logic::predicate compile-logic::args compile-logic::cont) #Y(compile-logic::compile-call nil nil (24 45 60 24 45 43 24 45 64 26 13 2 13 1 10 0 6 1 12 19 2 63 7 2 73 29) #1# #2# 4286) "Compile a call to a Prolog predicate." (defun compile-logic::prolog-compiler-macro) (#2# . 4401) (compile-logic::name) compile-logic::name get #Y(compile-logic::prolog-compiler-macro nil nil (24 45 136 26 13 0 15 116 19 2 137 29) #1# #2# 4401) "Fetch the compiler macro for a 
  Prolog predicate." compile-logic::def-prolog-compiler-macro (defmacro compile-logic::def-prolog-compiler-macro) (#2# . 4861) (compile-logic::name compile-logic::arglist &body compile-logic::body) #:g1109 #:g1108 #:g1110 si::dm-too-few-arguments compile-logic::arglist setf quote (quote compile-logic::prolog-compiler-macro) #Y(compile-logic::def-prolog-compiler-macro nil nil (24 45 144 24 45 145 26 10 1 5 45 146 10 0 76 39 6 13 2 19 1 147 10 0 4 12 10 0 5 51 0 22 45 136 10 1 76 39 6 13 3 19 1 147 10 1 4 12 10 1 5 51 1 22 45 148 10 2 45 113 15 149 15 137 15 150 10 2 6 2 12 1 151 6 3 12 15 25 15 124 13 1 10 0 7 3 6 2 6 3 73 29) #1# #2# 4861) "Define a compiler macro for Prolog." #:g1111 #:g1112 if second compile-logic::compile-unify #Y(nil nil nil (24 45 115 24 45 113 24 45 64 26 13 2 19 1 43 45 43 10 0 16 44 12 9 2 19 2 21 39 6 11 119 73 38 26 15 156 10 0 4 12 10 0 16 157 12 19 2 158 12 13 2 13 1 19 2 102 6 3 73 43 1 29) #1# #2# 5058) #:g1113 si::putprop compile-logic::+unbound+ "Unbound" si::*make-constant (defconstant compile-logic::+unbound+) (#2# . 5309) compile-logic::*var-counter* si::*make-special boundp (defvar compile-logic::*var-counter*) (#2# . 5470) compile-logic::var "VAR-" ((compile-logic::name #3=(incf compile-logic::*var-counter*)) (compile-logic::binding compile-logic::+unbound+)) ((compile-logic::name #3# t nil 0 nil) (compile-logic::binding compile-logic::+unbound+ t nil 1 nil)) compile-logic::copy-var compile-logic::print-var (#4=(compile-logic::? nil)) compile-logic::var-p si::define-structure #5=(compile-logic::var (:constructor . #4#) (:print-function compile-logic::print-var)) (defstruct #5#) (#2# . 5496) compile-logic::? (defun compile-logic::?) (#2# . 5496) (&aux (compile-logic::name (incf compile-logic::*var-counter*)) (compile-logic::binding compile-logic::+unbound+)) #:g1117 + compile-logic::binding 0 si::make-structure #Y(compile-logic::? nil nil (26 8 1 45 188 14 167 13 0 19 2 189 52 167 43 1 45 136 11 162 45 190 15 191 13 1 13 0 19 3 192 29) #1# #2# 5496) find-class compile-logic::var-binding symbol-package package ext::package-locked-p si::*ignore-package-locks* package-error "Ignore lock and proceed." "Attempt to define CAS accessor ~S in locked package." (compile-logic::var-binding) :package si::signal-simple-error mp::cas-expander #:g1120 si::x gensym si::new si::old mp::compare-and-swap-structure si::structure-ref #Y(nil nil nil (24 45 207 24 45 208 26 19 0 209 12 19 0 209 12 46 210 46 211 77 77 13 0 13 1 15 212 13 2 15 150 1 172 6 2 12 9 1 13 0 10 1 6 6 12 15 213 13 2 15 150 1 172 6 2 12 8 1 6 4 12 72 6 43 2 29) #1# #2# 5496) si::put-sysprop compile-logic::var-name (compile-logic::var-name) #:g1121 #Y(nil nil nil (24 45 218 24 45 208 26 19 0 209 12 19 0 209 12 46 210 46 211 77 77 13 0 13 1 15 212 13 2 15 150 1 172 6 2 12 9 0 13 0 10 1 6 6 12 15 213 13 2 15 150 1 172 6 2 12 8 0 6 4 12 72 6 43 2 29) #1# #2# 5496) compile-logic::bound-p (defun compile-logic::bound-p) (#2# . 5631) (compile-logic::var) eq #Y(compile-logic::bound-p nil nil (24 45 172 26 13 0 19 1 195 12 11 162 17 224 76 73 29) #1# #2# 5631) compile-logic::deref (defmacro compile-logic::deref) (#2# . 5695) (exp) #:g1123 #:g1122 #:g1124 exp si::dm-too-many-arguments progn loop compile-logic::while and do #Y(compile-logic::deref nil nil (24 45 230 24 45 231 26 10 1 5 45 232 10 0 76 39 6 13 2 19 1 147 10 0 4 12 10 0 5 51 0 22 45 233 10 1 39 6 13 3 19 1 234 15 235 15 236 15 237 15 238 15 179 10 0 6 2 12 15 220 10 0 6 2 6 3 12 15 239 15 149 13 0 15 195 10 0 6 2 6 3 6 5 12 10 0 6 3 73 29) #1# #2# 5695) "Follow pointers for bound variables." compile-logic::*trail* :fill-pointer :adjustable make-array (defvar compile-logic::*trail*) (#2# . 5900) compile-logic::set-binding! (defun compile-logic::set-binding!) (#2# . 5981) (compile-logic::var compile-logic::value) compile-logic::value vector-push-extend #:g1127 #:g1128 si::structure-set #Y(compile-logic::set-binding! nil nil (24 45 172 24 45 252 26 13 1 10 0 17 224 76 39 31 13 1 14 242 19 2 253 10 1 45 254 10 1 45 255 13 1 15 172 9 1 13 0 19 4 256 43 1 43 1 11 10 73 29) #1# #2# 5981) "Set var's bindinv to value, after 
  saving the variable in the trail.
  Always returns T." compile-logic::undo-bindings! (defun compile-logic::undo-bindings!) (#2# . 6212) (compile-logic::old-trail) compile-logic::old-trail fill-pointer vector-pop #:g1135 #:g1136 #Y(compile-logic::undo-bindings! nil nil (24 45 263 26 57 79 61 2 2 44 11 242 16 264 12 13 1 19 2 17 39 4 35 0 1 11 242 16 265 45 266 11 162 45 267 13 1 15 172 9 1 13 0 19 4 256 43 1 43 1 35 0 0 62 73 29) #1# #2# 6212) "Undo all bindings up to a given
  point in the trail." compile-logic::unify! (defun compile-logic::unify!) (#2# . 6451) (compile-logic::x compile-logic::y) eql consp #Y(compile-logic::unify! nil nil (24 45 50 24 45 108 26 57 79 61 2 2 29 13 2 19 1 179 39 6 13 2 19 1 220 76 39 4 35 0 1 13 2 19 1 195 51 2 35 0 0 62 13 1 57 79 61 2 2 29 13 1 19 1 179 39 6 13 1 19 1 220 76 39 4 35 0 1 13 1 19 1 195 51 1 35 0 0 62 10 0 17 274 39 6 11 10 73 38 74 13 1 19 1 179 39 10 13 1 13 0 19 2 248 38 58 13 0 19 1 179 39 10 13 0 13 1 19 2 248 38 42 10 1 16 275 39 5 10 0 16 275 39 28 10 1 4 12 10 0 4 12 19 2 270 73 39 12 10 1 5 12 10 0 5 12 19 2 270 38 3 75 73 29) #1# #2# 6451) "Destructively unify two expressions." (defun compile-logic::compile-unify) (#2# . 6748) (compile-logic::x compile-logic::y) #Y(compile-logic::compile-unify nil nil (24 45 50 24 45 108 26 15 270 13 1 19 1 122 12 13 0 19 1 122 6 3 73 29) #1# #2# 6748) "Return code that tests if x and y
  unify." compile-logic::compile-arg% (defun compile-logic::compile-arg%) (#2# . 6881) (compile-logic::arg) logic::variablep compile-logic::has-variable-p compile-logic::proper-list-p list cons #Y(compile-logic::compile-arg% nil nil (24 45 121 26 13 0 19 1 287 39 6 10 0 73 38 60 13 0 19 1 288 76 39 10 15 150 10 0 6 2 73 38 43 13 0 19 1 289 39 16 15 290 33 122 12 13 0 19 2 67 7 2 73 38 21 15 291 10 0 4 12 19 1 122 12 10 0 5 12 19 1 122 6 3 73 29) #1# #2# 6881) "Generate code for an argument to a 
  goal in the body." compile-logic::find-if-anywhere (defun compile-logic::find-if-anywhere) (#2# . 7207) (compile-logic::pred compile-logic::x) compile-logic::pred atom #Y(compile-logic::find-if-anywhere nil nil (24 45 298 24 45 50 26 13 1 13 0 20 1 23 39 6 10 0 73 38 32 10 0 16 299 39 5 75 73 38 22 13 1 10 0 4 12 19 2 294 73 40 10 13 1 10 0 5 12 19 2 294 29) #1# #2# 7207) (defun compile-logic::has-variable-p) (#2# . 7401) (compile-logic::x) #Y(compile-logic::has-variable-p nil nil (24 45 50 26 33 287 12 13 0 19 2 294 29) #1# #2# 7401) "Is there a variable anywhere in the 
  expression x?" (defun compile-logic::compile-predicate) (#2# . 7521) (symbol compile-logic::arity compile-logic::compilep compile-logic::clauses) (compile-logic::cont) #Y(nil nil nil (24 45 33 26 13 1 13 0 15 64 19 3 65 29) #1# #2# 7521) compile-logic::maybe-add-undo-bindings compile-logic::expr #Y(compile-logic::compile-predicate nil nil (24 45 9 24 45 16 24 45 11 24 45 13 26 13 3 13 2 19 2 57 45 60 13 3 19 1 58 45 59 15 61 13 1 13 0 15 309 19 2 63 12 34 310 12 13 2 19 2 67 12 19 1 311 6 4 45 312 10 4 39 11 10 0 16 68 12 19 1 69 38 4 10 0 73 43 3 29) #1# #2# 7521) "Compile all the clauses for a given
  symbol/arity into a single function." (defun compile-logic::compile-clause) (#2# . 8395) (compile-logic::parms compile-logic::clause compile-logic::cont) compile-logic::bind-unbound-vars #Y(compile-logic::compile-clause nil nil (24 45 98 24 45 33 24 45 64 26 13 2 33 99 12 13 2 13 1 19 1 14 12 19 1 43 12 19 3 67 12 13 1 19 1 100 12 19 2 101 12 13 0 19 2 102 12 19 2 318 29) #1# #2# 8395) "Transform away the head, and compile
  the resulting body." (defun compile-logic::maybe-add-undo-bindings) (#2# . 8719) (compile-logic::compiled-exps) compile-logic::compiled-exps symbolic::length=1 let ((compile-logic::old-trail (fill-pointer compile-logic::*trail*))) #:loop-list1148 #:loop-list-head1149 #:loop-list-tail1150 (compile-logic::undo-bindings! compile-logic::old-trail) #Y(compile-logic::maybe-add-undo-bindings nil nil (24 45 324 26 13 0 19 1 325 39 6 10 0 73 38 92 15 326 15 327 10 0 4 12 58 60 78 77 10 1 5 12 46 328 46 233 75 6 1 45 329 10 0 45 330 57 79 61 2 2 42 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 1 331 6 1 51 1 17 83 13 1 10 3 6 1 51 1 17 83 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 7 4 73 29) #1# #2# 8719) "Undo any bindings that need undoing.
  If there are any, bind the trail before
  we start." (defun compile-logic::bind-unbound-vars) (#2# . 9175) (compile-logic::parameters exp) logic::variables-in set-difference compile-logic::exp-vars (compile-logic::?) #Y(nil nil nil (24 45 172 26 13 0 1 340 6 2 73 29) #1# #2# 9175) #Y(compile-logic::bind-unbound-vars nil nil (24 45 59 24 45 233 26 13 0 19 1 337 12 13 1 19 2 338 45 339 10 0 39 19 15 326 1 341 12 13 0 19 2 67 12 10 1 6 3 73 38 4 10 1 73 43 1 29) #1# #2# 9175) "If there are any variables in exp 
  (besides the parameters), then bind 
  them to new vars." compile-logic::<- (defmacro compile-logic::<-) (#2# . 9601) (&rest compile-logic::clause) #:g1152 #:g1151 #:g1153 compile-logic::add-clause compile-logic::make-anonymous #Y(compile-logic::<- nil nil (24 45 348 24 45 349 26 10 1 5 45 350 10 0 45 33 15 351 15 150 13 0 19 1 352 6 2 6 2 73 29) #1# #2# 9601) "Add a clause to the database." (defun compile-logic::compile-arg) (#2# . 9878) (compile-logic::arg) (compile-logic::?) #Y(compile-logic::compile-arg nil nil (24 45 121 26 13 0 1 184 17 224 39 6 1 358 73 38 72 13 0 19 1 287 39 6 10 0 73 38 60 13 0 19 1 288 76 39 10 15 150 10 0 6 2 73 38 43 13 0 19 1 289 39 16 15 290 33 122 12 13 0 19 2 67 7 2 73 38 21 15 291 10 0 4 12 19 1 122 12 10 0 5 12 19 1 122 6 3 73 29) #1# #2# 9878) "Generate code for an argument to 
  a goal in the body." (defun compile-logic::make-anonymous) (#2# . 10226) (exp &optional (compile-logic::anon-vars (compile-logic::anonymous-variables-in exp))) compile-logic::anonymous-variables-in compile-logic::anon-vars more-efficiency::reuse-cons member #Y(compile-logic::make-anonymous nil nil (24 45 233 25 40 7 13 0 19 1 364 12 46 365 26 10 1 16 275 39 28 10 1 4 12 13 0 19 2 352 12 10 1 5 12 13 0 19 2 352 12 13 1 19 3 366 38 18 13 1 13 0 19 2 367 39 6 1 184 73 38 4 10 1 73 29) #1# #2# 10226) "Replace variables that are used only
  once with ?." (defun compile-logic::anonymous-variables-in) (#2# . 10620) (compile-logic::tree) compile-logic::tree compile-logic::seen-more compile-logic::seen-once delete #Y(compile-logic::walk nil nil (24 45 50 26 13 0 19 1 287 39 52 13 0 13 2 19 2 367 39 20 13 0 13 2 19 2 376 51 2 13 0 10 3 3 51 3 73 38 22 13 0 13 3 19 2 367 39 5 75 73 38 9 13 0 10 2 3 51 2 73 38 24 10 0 16 275 73 39 17 10 0 4 12 32 1 18 1 10 0 5 12 32 1 18 1 29) #1# #2# 10620) #Y(compile-logic::anonymous-variables-in nil nil (24 45 373 26 77 77 46 374 46 375 31 1 377 13 3 32 0 18 1 10 1 73 43 1 43 2 29) #1# #2# 10620) "Return a list of all variables that 
  occur only once in tree." compile-logic::*db-predicates* (defvar compile-logic::*db-predicates*) (#2# . 11386) compile-logic::*uncompiled* variable "Prolog symbols that have not been 
  compiled." (defvar compile-logic::*uncompiled*) (#2# . 11462) (defun compile-logic::add-clause) (#2# . 11541) (compile-logic::clause) (and (symbolp compile-logic::pred) (not (logic::variablep compile-logic::pred))) si::assert-failure symbolp adjoin #:g1173 #:g1174 #:g1175 #Y(compile-logic::add-clause nil nil (24 45 33 26 13 0 19 1 14 12 19 1 60 45 298 38 6 15 391 19 1 392 10 0 16 393 39 7 13 0 19 1 287 76 76 40 -19 13 0 14 380 19 2 394 52 380 13 0 14 383 19 2 394 52 383 10 0 45 395 1 13 45 396 13 2 19 1 12 12 10 3 6 1 12 19 2 101 45 397 13 2 13 0 13 1 19 3 161 43 1 43 2 10 0 73 43 1 29) #1# #2# 11541) "Add a clause to the database, 
  indexed by the predicate of the head." compile-logic::top-level-prove (defun compile-logic::top-level-prove) (#2# . 12024) (compile-logic::goals) compile-logic::goals compile-logic::top-level-query logic::clear-predicate compile-logic::vars (compile-logic::top-level-query) compile-logic::show-prolog-vars symbol-name compile-logic::top-level-query/0 compile-logic::ignore* compile-logic::run-prolog "~&No." format #Y(compile-logic::top-level-prove nil nil (24 45 404 26 15 405 19 1 406 15 184 13 0 19 1 337 12 19 2 376 45 407 15 408 13 1 15 409 33 410 12 13 0 19 2 67 12 10 0 6 1 12 19 2 63 7 2 6 1 12 19 2 63 7 2 12 19 1 351 43 1 15 411 33 412 12 19 2 413 14 10 15 414 19 2 415 0 29) #1# #2# 12024) "Prove the list of goals by compiling
  and proving it." (defun compile-logic::run-prolog) (#2# . 12584) (compile-logic::procedure compile-logic::cont) compile-logic::procedure compile-logic::prolog-compile-symbols si::fill-pointer-set #Y(compile-logic::run-prolog nil nil (24 45 421 24 45 64 26 19 0 422 14 242 8 0 17 423 8 0 52 167 1 400 59 60 9 13 2 13 1 20 1 23 63 29) #1# #2# 12584) "Run a 0-ary prolog procedure with
  a given continuation." (defun compile-logic::prolog-compile-symbols) (#2# . 12953) (&optional (compile-logic::symbols compile-logic::*uncompiled*)) compile-logic::symbols mapc #Y(compile-logic::prolog-compile-symbols nil nil (25 40 3 14 383 46 429 26 33 2 12 13 0 19 2 430 14 383 13 0 19 2 338 52 383 73 29) #1# #2# 12953) "Compile a list of Prolog symbols. By 
  default, the list is all symbols that
  need it." (defun compile-logic::ignore*) (#2# . 13243) (&rest compile-logic::args) #Y(compile-logic::ignore* nil nil (27 45 43 75 73 29) #1# #2# 13243) (defun compile-logic::show-prolog-vars) (#2# . 13492) (compile-logic::var-names compile-logic::vars compile-logic::cont) compile-logic::var-names "~&Yes." *standard-output* *query-io* make-broadcast-stream #:loop-list1185 "~&~A = ~A" compile-logic::deref-exp logic::continuep #Y(compile-logic::show-prolog-vars nil nil (24 45 440 24 45 407 24 45 64 26 10 1 76 39 10 14 10 15 441 19 2 415 38 64 14 442 14 443 19 2 444 48 442 77 13 2 46 445 46 136 57 79 61 2 2 37 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 14 10 15 446 13 1 14 172 19 1 447 12 19 4 415 35 0 0 62 43 2 44 1 19 0 448 39 8 13 0 20 0 23 38 6 15 400 75 73 37 29) #1# #2# 13492) "Display the variables, and prompt the
  user to see if we should continue. If 
  not, return to the top level." (defun compile-logic::deref-exp) (#2# . 14027) (exp) compile-logic::detef-exp #Y(compile-logic::deref-exp nil nil (24 45 233 26 57 79 61 2 2 29 13 1 19 1 179 39 6 13 1 19 1 220 76 39 4 35 0 1 13 1 19 1 195 51 1 35 0 0 62 10 0 16 299 39 6 10 0 73 38 22 10 0 4 12 19 1 447 12 10 0 5 12 19 1 454 12 13 0 19 3 366 29) #1# #2# 14027) "Build something equivalent to EXP with
  variables dereferenced." compile-logic::?- (defmacro compile-logic::?-) (#2# . 14260) (&rest compile-logic::goals) #:g1191 #:g1190 #:g1192 compile-logic::replace-?-vars #Y(compile-logic::?- nil nil (24 45 461 24 45 462 26 10 1 5 45 463 10 0 45 404 15 400 15 150 13 0 19 1 464 6 2 6 2 73 29) #1# #2# 14260) "Make a query and print answers.")) #2# 0) #Y(si::bytecodes nil nil (15 2 15 3 15 4 15 5 19 4 6 15 2 14 7 77 15 8 19 4 6 15 2 1 23 12 19 2 24 15 2 15 25 15 26 19 3 27 1 2 73 29) #1# #2# 93) #Y(si::bytecodes nil nil (15 18 15 3 15 28 15 29 19 4 6 15 18 14 7 77 15 30 19 4 6 15 18 1 37 12 19 2 24 15 18 15 25 15 38 19 3 27 1 18 73 29) #1# #2# 1501) #Y(si::bytecodes nil nil (15 15 15 3 15 39 15 40 19 4 6 15 15 14 7 77 15 41 19 4 6 15 15 1 45 12 19 2 24 15 15 15 25 15 46 19 3 27 1 15 73 29) #1# #2# 1749) #Y(si::bytecodes nil nil (15 43 15 3 15 47 15 48 19 4 6 15 43 14 7 77 15 49 19 4 6 15 43 1 51 12 19 2 24 15 43 15 25 15 52 19 3 27 1 43 73 29) #1# #2# 1854) #Y(si::bytecodes nil nil (15 53 15 3 15 54 15 55 19 4 6 15 53 14 7 77 15 56 19 4 6 15 53 34 70 12 19 2 24 15 53 15 25 15 71 19 3 27 1 53 73 29) #1# #2# 1915) #Y(si::bytecodes nil nil (15 58 15 3 15 72 15 73 19 4 6 15 58 14 7 77 15 74 19 4 6 15 58 1 85 12 19 2 24 15 58 15 25 15 86 19 3 27 1 58 73 29) #1# #2# 2454) #Y(si::bytecodes nil nil (15 57 15 3 15 87 15 88 19 4 6 15 57 14 7 77 15 89 19 4 6 15 57 1 92 12 19 2 24 15 57 15 25 15 93 19 3 27 1 57 73 29) #1# #2# 2614) #Y(si::bytecodes nil nil (15 94 15 3 15 95 15 96 19 4 6 15 94 14 7 77 15 97 19 4 6 15 94 1 103 12 19 2 24 15 94 15 25 15 104 19 3 27 1 94 73 29) #1# #2# 2726) #Y(si::bytecodes nil nil (15 99 15 3 15 105 15 106 19 4 6 15 99 14 7 77 15 107 19 4 6 15 99 1 109 12 19 2 24 1 99 73 29) #1# #2# 3209) #Y(si::bytecodes nil nil (15 102 15 3 15 110 15 111 19 4 6 15 102 14 7 77 15 112 19 4 6 15 102 1 126 12 19 2 24 15 102 15 25 15 127 19 3 27 1 102 73 29) #1# #2# 3248) #Y(si::bytecodes nil nil (15 125 15 3 15 128 15 129 19 4 6 15 125 14 7 77 15 130 19 4 6 15 125 1 131 12 19 2 24 15 125 15 25 15 132 19 3 27 1 125 73 29) #1# #2# 4286) #Y(si::bytecodes nil nil (15 116 15 3 15 133 15 134 19 4 6 15 116 14 7 77 15 135 19 4 6 15 116 1 138 12 19 2 24 15 116 15 25 15 139 19 3 27 1 116 73 29) #1# #2# 4401) #Y(si::bytecodes nil nil (15 140 15 3 15 141 15 142 19 4 6 15 140 14 7 77 15 143 19 4 6 15 140 1 152 12 14 10 9 3 19 4 24 15 140 15 25 15 153 19 3 27 1 140 73 29) #1# #2# 4861) #Y(si::bytecodes nil nil (1 17 45 154 1 116 45 155 1 159 45 160 13 2 13 0 13 1 19 3 161 43 1 43 2 29) #1# #2# 5058) #Y(si::bytecodes nil nil (15 162 1 163 17 164 15 162 15 3 15 165 15 166 19 4 6 1 162 73 29) #1# #2# 5309) #Y(si::bytecodes nil nil (1 167 16 168 1 167 16 169 76 39 5 8 0 52 167 15 167 15 3 15 170 15 171 19 4 6 1 167 73 29) #1# #2# 5470) #Y(si::bytecodes nil nil (15 172 15 173 77 77 15 174 15 175 15 176 77 15 177 77 15 178 9 2 77 77 15 179 19 15 180 15 181 15 3 15 182 15 183 19 4 6 15 184 15 3 15 185 15 186 19 4 6 15 184 14 7 77 15 187 19 4 6 15 172 19 1 194 78 191 15 184 1 193 12 19 2 24 1 195 16 196 45 197 10 0 39 10 10 0 16 198 39 4 11 199 76 39 16 15 200 15 201 15 202 15 203 14 204 13 0 19 6 205 43 1 15 195 15 206 1 214 12 19 3 215 1 216 16 196 45 197 10 0 39 10 10 0 16 198 39 4 11 199 76 39 16 15 200 15 201 15 202 15 217 14 204 13 0 19 6 205 43 1 15 216 15 206 1 219 12 19 3 215 1 172 73 29) #1# #2# 5496) #Y(si::bytecodes nil nil (15 220 15 3 15 221 15 222 19 4 6 15 220 14 7 77 15 223 19 4 6 15 220 1 225 12 19 2 24 1 220 73 29) #1# #2# 5631) #Y(si::bytecodes nil nil (15 226 15 3 15 227 15 228 19 4 6 15 226 14 7 77 15 229 19 4 6 15 226 1 240 12 14 10 9 2 19 4 24 15 226 15 25 15 241 19 3 27 1 226 73 29) #1# #2# 5695) #Y(si::bytecodes nil nil (1 242 16 168 1 242 16 169 76 39 16 9 200 14 243 9 0 14 244 14 10 19 5 245 52 242 15 242 15 3 15 246 15 247 19 4 6 1 242 73 29) #1# #2# 5900) #Y(si::bytecodes nil nil (15 248 15 3 15 249 15 250 19 4 6 15 248 14 7 77 15 251 19 4 6 15 248 1 257 12 19 2 24 15 248 15 25 15 258 19 3 27 1 248 73 29) #1# #2# 5981) #Y(si::bytecodes nil nil (15 259 15 3 15 260 15 261 19 4 6 15 259 14 7 77 15 262 19 4 6 15 259 1 268 12 19 2 24 15 259 15 25 15 269 19 3 27 1 259 73 29) #1# #2# 6212) #Y(si::bytecodes nil nil (15 270 15 3 15 271 15 272 19 4 6 15 270 14 7 77 15 273 19 4 6 15 270 1 276 12 19 2 24 15 270 15 25 15 277 19 3 27 1 270 73 29) #1# #2# 6451) #Y(si::bytecodes nil nil (15 158 15 3 15 278 15 279 19 4 6 15 158 14 7 77 15 280 19 4 6 15 158 1 281 12 19 2 24 15 158 15 25 15 282 19 3 27 1 158 73 29) #1# #2# 6748) #Y(si::bytecodes nil nil (15 283 15 3 15 284 15 285 19 4 6 15 283 14 7 77 15 286 19 4 6 15 283 1 292 12 19 2 24 15 283 15 25 15 293 19 3 27 1 283 73 29) #1# #2# 6881) #Y(si::bytecodes nil nil (15 294 15 3 15 295 15 296 19 4 6 15 294 14 7 77 15 297 19 4 6 15 294 1 300 12 19 2 24 1 294 73 29) #1# #2# 7207) #Y(si::bytecodes nil nil (15 288 15 3 15 301 15 302 19 4 6 15 288 14 7 77 15 303 19 4 6 15 288 1 304 12 19 2 24 15 288 15 25 15 305 19 3 27 1 288 73 29) #1# #2# 7401) #Y(si::bytecodes nil nil (15 19 15 3 15 306 15 307 19 4 6 15 19 14 7 77 15 308 19 4 6 15 19 34 313 12 19 2 24 15 19 15 25 15 314 19 3 27 1 19 73 29) #1# #2# 7521) #Y(si::bytecodes nil nil (15 65 15 3 15 315 15 316 19 4 6 15 65 14 7 77 15 317 19 4 6 15 65 1 319 12 19 2 24 15 65 15 25 15 320 19 3 27 1 65 73 29) #1# #2# 8395) #Y(si::bytecodes nil nil (15 311 15 3 15 321 15 322 19 4 6 15 311 14 7 77 15 323 19 4 6 15 311 1 332 12 19 2 24 15 311 15 25 15 333 19 3 27 1 311 73 29) #1# #2# 8719) #Y(si::bytecodes nil nil (15 318 15 3 15 334 15 335 19 4 6 15 318 14 7 77 15 336 19 4 6 15 318 1 342 12 19 2 24 15 318 15 25 15 343 19 3 27 1 318 73 29) #1# #2# 9175) #Y(si::bytecodes nil nil (15 344 15 3 15 345 15 346 19 4 6 15 344 14 7 77 15 347 19 4 6 15 344 1 353 12 14 10 9 1 19 4 24 15 344 15 25 15 354 19 3 27 1 344 73 29) #1# #2# 9601) #Y(si::bytecodes nil nil (15 122 15 3 15 355 15 356 19 4 6 15 122 14 7 77 15 357 19 4 6 15 122 1 359 12 19 2 24 15 122 15 25 15 360 19 3 27 1 122 73 29) #1# #2# 9878) #Y(si::bytecodes nil nil (15 352 15 3 15 361 15 362 19 4 6 15 352 14 7 77 15 363 19 4 6 15 352 1 368 12 19 2 24 15 352 15 25 15 369 19 3 27 1 352 73 29) #1# #2# 10226) #Y(si::bytecodes nil nil (15 364 15 3 15 370 15 371 19 4 6 15 364 14 7 77 15 372 19 4 6 15 364 34 378 12 19 2 24 15 364 15 25 15 379 19 3 27 1 364 73 29) #1# #2# 10620) #Y(si::bytecodes nil nil (1 380 16 168 1 380 16 169 76 39 4 75 52 380 15 380 15 3 15 381 15 382 19 4 6 1 380 73 29) #1# #2# 11386) #Y(si::bytecodes nil nil (1 383 16 168 1 383 16 169 76 39 4 75 52 383 15 383 15 384 15 385 19 3 27 15 383 15 3 15 386 15 387 19 4 6 1 383 73 29) #1# #2# 11462) #Y(si::bytecodes nil nil (15 351 15 3 15 388 15 389 19 4 6 15 351 14 7 77 15 390 19 4 6 15 351 1 398 12 19 2 24 15 351 15 25 15 399 19 3 27 1 351 73 29) #1# #2# 11541) #Y(si::bytecodes nil nil (15 400 15 3 15 401 15 402 19 4 6 15 400 14 7 77 15 403 19 4 6 15 400 1 416 12 19 2 24 15 400 15 25 15 417 19 3 27 1 400 73 29) #1# #2# 12024) #Y(si::bytecodes nil nil (15 413 15 3 15 418 15 419 19 4 6 15 413 14 7 77 15 420 19 4 6 15 413 1 424 12 19 2 24 15 413 15 25 15 425 19 3 27 1 413 73 29) #1# #2# 12584) #Y(si::bytecodes nil nil (15 422 15 3 15 426 15 427 19 4 6 15 422 14 7 77 15 428 19 4 6 15 422 1 431 12 19 2 24 15 422 15 25 15 432 19 3 27 1 422 73 29) #1# #2# 12953) #Y(si::bytecodes nil nil (15 412 15 3 15 433 15 434 19 4 6 15 412 14 7 77 15 435 19 4 6 15 412 1 436 12 19 2 24 1 412 73 29) #1# #2# 13243) #Y(si::bytecodes nil nil (15 409 15 3 15 437 15 438 19 4 6 15 409 14 7 77 15 439 19 4 6 15 409 1 449 12 19 2 24 15 409 15 25 15 450 19 3 27 1 409 73 29) #1# #2# 13492) #Y(si::bytecodes nil nil (15 447 15 3 15 451 15 452 19 4 6 15 447 14 7 77 15 453 19 4 6 15 447 1 455 12 19 2 24 15 447 15 25 15 456 19 3 27 1 447 73 29) #1# #2# 14027) #Y(si::bytecodes nil nil (15 457 15 3 15 458 15 459 19 4 6 15 457 14 7 77 15 460 19 4 6 15 457 1 465 12 14 10 9 1 19 4 24 15 457 15 25 15 466 19 3 27 1 457 73 29) #1# #2# 14260))
