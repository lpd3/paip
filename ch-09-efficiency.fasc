(#Y(si::bytecodes nil nil (1 0 16 1 29) #1=#A(t (569) ("EFFICIENCY" si::select-package efficiency::fib ext::location (defun efficiency::fib) (#2=#P"/data/data/org.eql5.android.repl/files/quicklisp/local-projects/paip/ch-09-efficiency.lisp" . 117) ext::annotate :lambda-list (efficiency::n) efficiency::n <= - + #Y(efficiency::fib nil nil (24 45 9 26 13 0 9 1 19 2 10 39 6 8 1 73 38 28 13 0 9 1 19 2 11 12 19 1 2 12 13 0 9 2 19 2 11 12 19 1 2 12 19 2 12 29) #1# #2# 117) si::fset function "Computes the nth number in the 
  Fibonacci sequence. Simple but 
  horribly inefficient approach." si::set-documentation efficiency::memo% (defun efficiency::memo%) (#2# . 325) (efficiency::fn) efficiency::fn make-hash-table efficiency::table efficiency::x efficiency::args gethash efficiency::foundp efficiency::val si::hash-set #Y(nil nil nil (24 45 25 26 14 26 13 1 19 2 27 47 1 28 45 29 10 1 39 6 10 0 73 38 16 14 26 13 3 13 4 13 2 20 1 23 12 19 3 30 43 2 29) #1# #2# 325) #Y(efficiency::memo% nil nil (24 45 22 26 19 0 23 45 24 34 31 73 43 1 29) #1# #2# 325) "Given a function, return a memoized
  version of the function." efficiency::memoize% (defun efficiency::memoize%) (#2# . 668) (efficiency::fn-name) efficiency::fn-name symbol-function efficiency::memo #Y(efficiency::memoize% nil nil (24 45 38 26 13 0 10 0 16 39 12 19 1 40 12 19 2 14 29) #1# #2# 668) "Given a function, reassign its name
  to a memoized version of the function." efficiency::defun-memo% (defmacro efficiency::defun-memo%) (#2# . 853) (efficiency::fn efficiency::args &body efficiency::body) #:g542 #:g541 #:g543 si::dm-too-few-arguments efficiency::body efficiency::memoize defun #Y(efficiency::defun-memo% nil nil (24 45 47 24 45 48 26 10 1 5 45 49 10 0 76 39 6 13 2 19 1 50 10 0 4 12 10 0 5 51 0 22 45 22 10 1 76 39 6 13 3 19 1 50 10 1 4 12 10 1 5 51 1 22 45 26 10 2 45 51 15 52 15 53 13 2 13 1 10 0 7 4 6 2 73 29) #1# #2# 853) t "Define a memoized function." (defun efficiency::memo) (#2# . 968) (efficiency::fn-name &key (efficiency::memo-name efficiency::fn-name) (efficiency::key (function identity)) (efficiency::test (function equal))) (nil :test :key :memo-name) efficiency::memo-name identity efficiency::key equal efficiency::test :test efficiency::old-fn #:g550 #:g551 #:g552 si::putprop efficiency::k apply #Y(nil nil nil (27 45 26 13 4 13 0 20 1 23 45 72 13 0 13 2 19 2 27 47 1 28 45 29 10 1 39 6 10 0 73 38 16 13 2 13 4 13 5 13 3 19 2 73 12 19 3 30 43 2 43 1 29) #1# #2# 968) #Y(efficiency::memo nil nil (24 45 38 28 60 22 40 3 13 0 46 61 22 40 4 33 62 12 46 63 22 40 4 33 64 12 46 65 14 66 13 0 19 2 23 12 10 3 16 39 12 46 67 46 24 10 4 45 68 1 24 45 69 10 2 45 70 13 2 13 0 13 1 19 3 71 43 1 43 2 34 74 73 43 2 29) #1# #2# 968) "Given a function name, return a memoized
  version of its function. Improved
  version. Kwargs include :memo-name
  the symbol that will hold the 
  memoization table as a property 
  value. Defaults to the supplied 
  function name. :key specifies
  which argument to use for keys in 
  the memo table. Defaults to #'identity, 
  meaning the complete list of args is 
  the key. :test is the hash-table test for
  the memo table. Defaults to #'equal, as
  must be the case when :key is #'identity." (defun efficiency::memoize) (#2# . 2065) (efficiency::fn-name &key (efficiency::memo-name efficiency::fn-name) (efficiency::key (function identity)) (efficiency::test (function equal))) (nil :test :key :memo-name) :memo-name :key #Y(efficiency::memoize nil nil (24 45 38 28 80 22 40 3 13 0 46 61 22 40 4 33 62 12 46 63 22 40 4 33 64 12 46 65 13 3 13 3 14 81 13 2 14 82 13 1 14 66 13 0 19 7 40 12 19 2 14 29) #1# #2# 2065) "Given a function name, replace its
  function with a memoized version of 
  the function. Takes kwargs which are 
  passed to memo." efficiency::rule-lhs (defun efficiency::rule-lhs) (#2# . 2494) (efficiency::rule) efficiency::rule #Y(efficiency::rule-lhs nil nil (24 45 89 26 10 0 4 73 29) #1# #2# 2494) "The left-hand side of a rule." efficiency::rule-rhs (defun efficiency::rule-rhs) (#2# . 2723) (efficiency::rule) #Y(efficiency::rule-rhs nil nil (24 45 89 26 10 0 5 5 73 29) #1# #2# 2723) "The right-hand side of a rule." efficiency::one-of (defun efficiency::one-of) (#2# . 2804) (set) set efficiency::random-elt #Y(efficiency::one-of nil nil (24 45 102 26 13 0 19 1 103 6 1 73 29) #1# #2# 2804) "Pick one element at random from a set
  and make a list of it." (defun efficiency::random-elt) (#2# . 2919) (efficiency::choices) efficiency::choices length random elt #Y(efficiency::random-elt nil nil (24 45 109 26 13 0 10 0 16 110 12 19 1 111 17 112 29) #1# #2# 2919) "Given a sequence, return a random element." efficiency::compile-rule (defun efficiency::compile-rule) (#2# . 3038) (efficiency::rule) efficiency::rhs atom every quote symbolic::length=1 efficiency::build-code case efficiency::build-cases #Y(efficiency::compile-rule nil nil (24 45 89 26 13 0 19 1 92 45 119 15 53 13 1 19 1 85 12 77 33 120 12 13 0 19 2 121 39 13 15 98 15 122 10 0 6 2 6 2 38 37 13 0 19 1 123 39 10 10 0 4 12 19 1 124 38 21 15 125 15 111 10 0 16 110 6 2 12 9 0 13 0 19 2 126 7 3 6 4 73 43 1 29) #1# #2# 3038) "Translate a grammar rule into a CL 
  function definition." (defun efficiency::build-cases) (#2# . 3437) (number efficiency::choices) number 1+ #Y(efficiency::build-cases nil nil (24 45 132 24 45 109 26 10 0 73 39 27 13 1 10 0 4 12 19 1 124 6 2 12 10 1 16 133 12 10 0 5 12 19 2 126 3 73 29) #1# #2# 3437) "Return a list of case clauses." (defun efficiency::build-code) (#2# . 3666) (efficiency::choice) efficiency::choice append mapcar #Y(efficiency::build-code nil nil (24 45 139 26 10 0 76 39 5 75 73 38 27 10 0 16 120 39 8 10 0 6 1 73 38 14 15 140 33 124 12 13 0 19 2 141 7 2 73 29) #1# #2# 3666) "Append together multiple constituents" efficiency::defrule (defmacro efficiency::defrule) (#2# . 3870) (&rest efficiency::rule) #:g561 #:g560 #:g562 #Y(efficiency::defrule nil nil (24 45 148 24 45 149 26 10 1 5 45 150 10 0 45 89 13 0 19 1 115 29) #1# #2# 3870) "Define a grammar rule." efficiency::delay "DELAY-" ((efficiency::value nil) (function nil)) ((efficiency::value nil t nil 0 nil) (function nil t nil 1 nil)) efficiency::copy-delay (efficiency::make-delay) efficiency::delay-p si::define-structure (defstruct efficiency::delay) (#2# . 4314) efficiency::make-delay (defun efficiency::make-delay) (#2# . 4314) (&key #3=#:value #4=#:function) (nil :function :value) #3# #4# 0 si::make-structure #Y(efficiency::make-delay nil nil (28 167 22 40 2 77 46 168 22 40 2 77 46 169 15 170 13 1 13 0 19 3 171 29) #1# #2# 4314) find-class efficiency::delay-function symbol-package package ext::package-locked-p si::*ignore-package-locks* package-error "Ignore lock and proceed." "Attempt to define CAS accessor ~S in locked package." (efficiency::delay-function) :package si::signal-simple-error mp::cas-expander #:g565 si::x gensym si::new si::old mp::compare-and-swap-structure si::structure-ref #Y(nil nil nil (24 45 186 24 45 187 26 19 0 188 12 19 0 188 12 46 189 46 190 77 77 13 0 13 1 15 191 13 2 15 122 1 153 6 2 12 9 1 13 0 10 1 6 6 12 15 192 13 2 15 122 1 153 6 2 12 8 1 6 4 12 72 6 43 2 29) #1# #2# 4314) si::put-sysprop efficiency::delay-value (efficiency::delay-value) #:g566 #Y(nil nil nil (24 45 197 24 45 187 26 19 0 188 12 19 0 188 12 46 189 46 190 77 77 13 0 13 1 15 191 13 2 15 122 1 153 6 2 12 9 0 13 0 10 1 6 6 12 15 192 13 2 15 122 1 153 6 2 12 8 0 6 4 12 72 6 43 2 29) #1# #2# 4314) (defmacro efficiency::delay) (#2# . 5474) (&body efficiency::body) #:g568 #:g567 #:g569 :function lambda #Y(efficiency::delay nil nil (24 45 202 24 45 203 26 10 1 5 45 204 10 0 45 51 15 163 14 205 15 15 15 206 77 10 0 7 3 6 2 6 3 73 29) #1# #2# 5474) "A computation that can be executed later
  by the ``force'' function." efficiency::force (defun efficiency::force) (#2# . 5632) (efficiency::x) #:g574 #:g575 si::structure-set #:g576 #:g577 #Y(efficiency::force nil nil (24 45 25 26 13 0 19 1 159 39 67 13 0 19 1 174 39 53 10 0 45 213 13 1 19 1 174 12 20 0 23 45 214 13 1 15 153 9 0 13 0 19 4 215 43 1 43 1 10 0 45 216 75 45 217 13 1 15 153 9 1 13 0 19 4 215 43 1 43 1 13 0 19 1 195 38 4 10 0 73 29) #1# #2# 5632) "Find the value of x, by computing it
  if it is a delay." efficiency::make-pipe% (defmacro efficiency::make-pipe%) (#2# . 5914) (efficiency::head efficiency::tail) #:g579 #:g578 #:g580 efficiency::head efficiency::tail si::dm-too-many-arguments cons #Y(efficiency::make-pipe% nil nil (24 45 224 24 45 225 26 10 1 5 45 226 10 0 76 39 6 13 2 19 1 50 10 0 4 12 10 0 5 51 0 22 45 227 10 1 76 39 6 13 3 19 1 50 10 1 4 12 10 1 5 51 1 22 45 228 10 2 39 6 13 4 19 1 229 15 230 13 1 15 153 10 0 6 2 6 3 73 29) #1# #2# 5914) "Create a pipe by evaluating head and
  delaying tail." efficiency::*empty-pipe* si::*make-constant (defconstant efficiency::*empty-pipe*) (#2# . 6347) (defun efficiency::head) (#2# . 6379) (efficiency::pipe) efficiency::pipe #Y(efficiency::head nil nil (24 45 240 26 10 0 4 73 29) #1# #2# 6379) efficiency::tail% (defun efficiency::tail%) (#2# . 6415) (efficiency::pipe) #Y(efficiency::tail% nil nil (24 45 240 26 10 0 5 12 19 1 209 29) #1# #2# 6415) efficiency::pipe-elt (defun efficiency::pipe-elt) (#2# . 6463) (efficiency::pipe efficiency::i) efficiency::i zerop 1- #Y(efficiency::pipe-elt nil nil (24 45 240 24 45 251 26 10 0 16 252 39 8 13 1 19 1 227 38 15 13 1 19 1 228 12 10 0 16 253 12 19 2 247 29) #1# #2# 6463) "The i'th element of a pipe, 0-based" efficiency::integers (defun efficiency::integers) (#2# . 6601) (&optional (efficiency::start 0) efficiency::end) efficiency::start efficiency::end efficiency::make-pipe #Y(efficiency::integers nil nil (25 40 3 9 0 46 260 25 40 2 77 46 261 26 10 0 76 40 8 13 1 13 0 19 2 10 39 19 13 1 10 1 16 133 12 13 0 19 2 256 12 19 2 262 38 3 75 73 29) #1# #2# 6601) "A pipe of integers. Optional args
  start defaults to 0. End defaults to
  nil. If end is nil, pipe is infinitely
  long." (defmacro efficiency::make-pipe) (#2# . 6961) (efficiency::head efficiency::tail) #:g582 #:g581 #:g583 #Y(efficiency::make-pipe nil nil (24 45 268 24 45 269 26 10 1 5 45 270 10 0 76 39 6 13 2 19 1 50 10 0 4 12 10 0 5 51 0 22 45 227 10 1 76 39 6 13 3 19 1 50 10 1 4 12 10 1 5 51 1 22 45 228 10 2 39 6 13 4 19 1 229 15 230 13 1 15 15 15 206 77 10 0 6 3 6 2 6 3 73 29) #1# #2# 6961) "Create a pipe by evaluating head and
  delaying tail." (defun efficiency::tail) (#2# . 8062) (efficiency::pipe) functionp #:g586 #:g587 rplacd #Y(efficiency::tail nil nil (24 45 240 26 10 0 5 16 276 39 29 10 0 45 277 10 1 5 12 20 0 23 45 278 13 1 10 0 17 279 10 0 73 43 1 43 1 38 5 10 0 5 73 29) #1# #2# 8062) "Return tail of pipe or list, and 
  destructively update the tail if it 
  is a function." efficiency::enumerate (defun efficiency::enumerate) (#2# . 8289) (efficiency::pipe &key count efficiency::key (efficiency::result efficiency::pipe)) (nil :result :key :count) count efficiency::result eq :count :result #Y(efficiency::enumerate nil nil (24 45 240 28 286 22 40 2 77 46 287 22 40 2 77 46 63 22 40 3 13 2 46 288 13 3 11 233 17 289 40 8 13 2 9 0 19 2 10 39 6 10 0 73 38 45 10 1 39 12 13 1 13 3 19 1 227 12 20 1 23 13 3 19 1 228 12 14 290 10 2 73 39 5 10 2 16 253 12 14 82 13 1 14 291 13 0 19 7 282 29) #1# #2# 8289) "(enumerate pipe &key count key 
   (result pipe)).
   pipe: a pipe object
   count: non-negative integer or nil
   key: function of one arg
   result: an object. Goes through each
   element of pipe, or stops after :count
   is reached. Applies :key to each 
   element encountered. Returns :result." efficiency::filter (defun efficiency::filter) (#2# . 9248) (efficiency::pred efficiency::pipe) efficiency::pred #Y(nil nil nil (26 13 1 13 0 19 1 228 12 19 2 294 29) #1# #2# 9248) #Y(efficiency::filter nil nil (24 45 298 24 45 240 26 13 1 13 0 19 1 227 12 20 1 23 39 13 13 0 19 1 227 12 34 299 3 73 38 12 13 1 13 0 19 1 228 12 19 2 294 29) #1# #2# 9248) "Takes a predicate function and a 
  pipe object. Returns a pipe object 
  whose calculated contents contain
  only items that pass the predicate." efficiency::sieve (defun efficiency::sieve) (#2# . 9565) (efficiency::pipe) mod /= #Y(nil nil nil (24 45 25 26 13 0 13 1 19 1 227 17 306 12 9 0 19 2 307 29) #1# #2# 9565) #Y(nil nil nil (26 34 308 12 13 0 19 1 228 12 19 1 302 12 19 2 294 29) #1# #2# 9565) #Y(efficiency::sieve nil nil (24 45 240 26 13 0 19 1 227 12 34 309 3 73 29) #1# #2# 9565) efficiency::*primes* si::*make-special boundp (defvar efficiency::*primes*) (#2# . 9750) efficiency::populate-primes (defun efficiency::populate-primes) (#2# . 10050) #Y(efficiency::populate-primes nil nil (26 9 2 19 1 256 12 19 1 302 52 311 73 29) #1# #2# 10050) efficiency::map-pipe (defun efficiency::map-pipe) (#2# . 10121) (efficiency::fn efficiency::pipe) #Y(nil nil nil (26 13 1 13 0 19 1 228 12 19 2 320 29) #1# #2# 10121) #Y(efficiency::map-pipe nil nil (24 45 22 24 45 240 26 13 0 11 233 17 289 39 6 11 233 73 38 17 13 1 13 0 19 1 227 12 20 1 23 12 34 324 3 73 29) #1# #2# 10121) "Takes a function of one arg and 
  a pipe object. Maps function over 
  the elements in the pipe, delaying
  all but the first function call." efficiency::append-pipes (defun efficiency::append-pipes) (#2# . 10773) (efficiency::x efficiency::y) efficiency::y #Y(nil nil nil (26 13 1 19 1 228 12 13 0 19 2 327 29) #1# #2# 10773) #Y(efficiency::append-pipes nil nil (24 45 25 24 45 331 26 13 1 11 233 17 289 39 6 10 0 73 38 11 13 1 19 1 227 12 34 332 3 73 29) #1# #2# 10773) "Given two pipes, the first of which
  is presumably of finite length, 
  return a pipe that is the concatenation
  of the elements of the two pipes." efficiency::mappend-pipe (defun efficiency::mappend-pipe) (#2# . 11056) (efficiency::fn efficiency::pipe) #Y(nil nil nil (26 13 0 19 1 228 12 13 2 13 1 19 1 228 12 19 2 335 12 19 2 327 29) #1# #2# 11056) #Y(efficiency::mappend-pipe nil nil (24 45 22 24 45 240 26 13 0 11 233 17 289 39 6 11 233 73 38 26 13 1 13 0 19 1 227 12 20 1 23 45 25 13 0 19 1 227 12 34 339 3 73 43 1 29) #1# #2# 11056) "Given a function of one argument
  that produces a list and a pipe, 
  return a pipe which contains the
  appended lists produced by mapping
  the function over the elements in the
  pipe argument." efficiency::profile1% (defun efficiency::profile1%) (#2# . 11510) (efficiency::fn-name) #:g596 #:g597 :unprofiled-fn #:g598 #:g599 :profile-count efficiency::profiled-fn #Y(efficiency::profile1% nil nil (24 45 38 26 10 0 16 39 45 22 10 1 45 346 10 1 45 347 13 1 13 0 14 348 19 3 71 43 1 43 1 10 1 45 349 8 0 45 350 13 1 13 0 14 351 19 3 71 43 1 43 1 13 1 13 1 13 0 19 2 352 12 19 2 14 10 1 73 43 1 29) #1# #2# 11510) "Make the function count how often
  it is called. The sole arg is the 
  quoted function name, NOT a function
  literal." efficiency::unprofile1% (defun efficiency::unprofile1%) (#2# . 12487) (efficiency::fn-name) get remprop #Y(efficiency::unprofile1% nil nil (24 45 38 26 13 0 13 0 14 348 19 2 359 12 19 2 14 13 0 11 348 17 360 13 0 11 351 17 360 10 0 73 29) #1# #2# 12487) "Given the quoted symbol 
  fbound to a profiled function, 
  restore the symbol's bunding
  to the original, unprofiled function." efficiency::profiled-fn% (defun efficiency::profiled-fn%) (#2# . 12808) (efficiency::fn-name efficiency::fn) #:g609 #:g611 #:g610 #Y(nil nil nil (27 45 26 10 2 45 367 8 1 45 368 13 1 14 351 19 2 359 12 13 0 19 2 12 45 369 13 2 13 0 14 351 19 3 71 43 3 13 1 13 0 19 2 73 29) #1# #2# 12808) #Y(efficiency::profiled-fn% nil nil (24 45 38 24 45 22 26 34 370 73 29) #1# #2# 12808) "Return a function that 
  increments the count." efficiency::profile-count (defun efficiency::profile-count) (#2# . 12989) (efficiency::fn-name) #Y(efficiency::profile-count nil nil (24 45 38 26 13 0 14 351 19 2 359 29) #1# #2# 12989) efficiency::profile-report% (defun efficiency::profile-report%) (#2# . 13053) (efficiency::fn-names &optional (efficiency::key (function efficiency::profile-count))) efficiency::fn-names > sort si::%dolist-var efficiency::name "~&~7D ~A" format #Y(efficiency::profile-report% nil nil (24 45 382 25 40 4 33 373 12 46 63 26 13 1 33 383 12 14 82 13 0 19 4 384 45 385 38 28 10 0 4 45 386 14 55 15 387 13 0 19 1 373 12 13 0 19 4 388 10 1 5 51 1 43 1 10 0 40 -30 75 73 43 1 29) #1# #2# 13053) "Report profiling statistics on given
  functions." efficiency::*profiled-functions* variable "Function names that are currently
  profiled." (defvar efficiency::*profiled-functions*) (#2# . 13387) efficiency::profile1 (defun efficiency::profile1) (#2# . 13921) (efficiency::fn-name) :profiled-fn efficiency::new-fn #:g624 #:g625 #:g626 #:g627 #:g628 #:g629 :profile-time #:g630 #:g631 #Y(efficiency::profile1 nil nil (24 45 38 26 10 0 16 39 45 22 13 0 13 1 14 400 19 2 359 17 289 76 39 103 13 1 13 0 19 2 352 45 401 13 2 13 0 19 2 14 10 2 45 402 10 1 45 403 13 1 13 0 14 400 19 3 71 43 1 43 1 10 2 45 404 10 2 45 405 13 1 13 0 14 348 19 3 71 43 1 43 1 10 2 45 406 8 0 45 407 13 1 13 0 14 408 19 3 71 43 1 43 1 10 2 45 409 8 0 45 410 13 1 13 0 14 351 19 3 71 43 1 43 1 43 1 43 1 10 0 73 29) #1# #2# 13921) "Make the function count how often
  it was called." efficiency::unprofile1 (defun efficiency::unprofile1) (#2# . 14593) (efficiency::fn-name) #:g638 #:g639 #:g640 #:g641 #Y(efficiency::unprofile1 nil nil (24 45 38 26 10 0 45 417 8 0 45 418 13 1 13 0 14 408 19 3 71 43 1 43 1 10 0 45 419 8 0 45 420 13 1 13 0 14 351 19 3 71 43 1 43 1 10 0 16 39 12 13 0 14 400 19 2 359 17 289 39 14 13 0 13 0 14 348 19 2 359 12 19 2 14 10 0 73 29) #1# #2# 14593) "Make the function stop counting how
  often it is called." efficiency::profile (defmacro efficiency::profile) (#2# . 14975) (&rest efficiency::fn-names) #:g645 #:g644 #:g646 (function efficiency::profile1) setf union #Y(efficiency::profile nil nil (24 45 427 24 45 428 26 10 1 5 45 429 10 0 45 382 15 141 15 430 15 431 15 391 15 432 15 391 10 0 6 3 6 3 6 3 73 29) #1# #2# 14975) "Profile the supplied function
  names. With no args, returns a list
  of profiled functions." efficiency::get-fast-time (defun efficiency::get-fast-time) (#2# . 15226) get-internal-real-time #Y(efficiency::get-fast-time nil nil (26 19 0 438 29) #1# #2# 15226) "Return the elapsed time." efficiency::fast-time-difference (defun efficiency::fast-time-difference) (#2# . 15308) (efficiency::end efficiency::start) #Y(efficiency::fast-time-difference nil nil (24 45 261 24 45 260 26 13 1 13 0 19 2 11 29) #1# #2# 15308) "Subtract two time points." efficiency::fast-time->seconds (defun efficiency::fast-time->seconds) (#2# . 15398) (time) time internal-time-units-per-second / 0.0d0 float #Y(efficiency::fast-time->seconds nil nil (24 45 451 26 13 0 14 452 19 2 453 12 15 454 19 2 455 29) #1# #2# 15398) "Convert a fast-time interval to 
  seconds." efficiency::unprofile (defmacro efficiency::unprofile) (#2# . 15546) (&rest efficiency::fn-names) #:g648 #:g647 #:g649 progn (function efficiency::unprofile1) set-difference #Y(efficiency::unprofile nil nil (24 45 462 24 45 463 26 10 1 5 45 464 10 0 45 382 15 465 15 141 15 466 10 0 39 5 10 0 38 3 1 391 6 3 12 15 431 15 391 10 0 39 15 15 467 15 391 15 122 10 0 6 2 6 3 38 2 75 6 3 6 3 73 29) #1# #2# 15546) "Stop profiling supplied fn-names. With
  no args, stop profiling all functions." (inline efficiency::profile-enter efficiency::profile-exit efficiency::inc-profile-time) proclaim (defun efficiency::profiled-fn) (#2# . 16060) (efficiency::fn-name efficiency::fn) efficiency::profile-enter efficiency::profile-exit #Y(nil nil nil (27 45 26 13 2 19 1 475 13 1 13 0 19 2 73 69 13 2 19 1 476 70 29) #1# #2# 16060) #Y(efficiency::profiled-fn nil nil (24 45 38 24 45 22 26 34 477 73 29) #1# #2# 16060) "Return a function that increments 
  the count, and times." efficiency::*profile-call-stack* (defvar efficiency::*profile-call-stack*) (#2# . 16295) (defun efficiency::profile-enter) (#2# . 16330) (efficiency::fn-name) #:g654 #:g656 #:g655 efficiency::inc-profile-time #Y(efficiency::profile-enter nil nil (24 45 38 26 10 0 45 486 8 1 45 487 13 1 14 351 19 2 359 12 13 0 19 2 12 45 488 13 2 13 0 14 351 19 3 71 43 3 11 480 39 13 11 480 4 12 11 480 4 4 12 19 2 489 13 0 19 0 435 3 12 11 480 3 52 480 73 29) #1# #2# 16330) (defun efficiency::profile-exit) (#2# . 16693) (efficiency::fn-name) #:g661 #:g662 #:g663 #Y(efficiency::profile-exit nil nil (24 45 38 26 11 480 45 494 10 0 4 12 10 0 5 51 0 10 0 52 480 43 1 13 0 19 2 489 11 480 73 39 24 11 480 4 45 495 19 0 435 45 496 13 1 10 0 17 279 10 0 73 43 1 43 1 29) #1# #2# 16693) (defun efficiency::inc-profile-time) (#2# . 17010) (efficiency::entry efficiency::fn-name) efficiency::entry #:g667 #:g669 #:g668 #Y(efficiency::inc-profile-time nil nil (24 45 501 24 45 38 26 10 0 45 502 19 0 435 12 10 2 5 12 19 2 441 45 503 13 1 14 408 19 2 359 12 13 0 19 2 12 45 504 13 2 13 0 14 408 19 3 71 43 3 29) #1# #2# 17010) efficiency::profile-report (defun efficiency::profile-report) (#2# . 17157) (&optional (efficiency::fn-names (copy-list efficiency::*profiled-functions*)) (efficiency::key (function efficiency::profile-count))) copy-list efficiency::profile-time reduce efficiency::total-time "~&Total elapsed time: ~D seconds." "~&Count Secs Time% Name" #:loop-list673 0 "~&~7D ~6,2F ~A% ~A" efficiency::nan 0.01 round #Y(efficiency::profile-report nil nil (25 40 6 11 391 16 510 12 46 382 25 40 4 33 373 12 46 63 26 33 12 12 33 511 12 13 1 19 2 141 12 19 2 512 45 513 10 1 39 15 13 2 33 383 12 14 82 13 1 19 4 384 51 2 14 55 15 514 13 0 19 1 447 12 19 3 388 14 55 15 515 19 2 388 77 13 2 46 516 46 386 57 517 61 2 2 76 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 14 55 15 518 13 1 19 1 373 12 13 1 19 1 511 12 19 1 447 12 10 3 16 252 39 6 1 519 73 38 18 13 1 19 1 511 12 13 3 19 2 453 12 15 520 19 2 521 12 13 1 19 6 388 35 0 0 62 73 43 2 43 1 29) #1# #2# 17157) "Report profiling statistics on given
  functions." (defun efficiency::profile-time) (#2# . 17993) (efficiency::fn-name) #Y(efficiency::profile-time nil nil (24 45 38 26 13 0 14 408 19 2 359 29) #1# #2# 17993) efficiency::with-profiling (defmacro efficiency::with-profiling) (#2# . 18055) (efficiency::fn-names &body efficiency::body) #:g675 #:g674 #:g676 (setf efficiency::*profile-call-stack* nil) unwind-protect #Y(efficiency::with-profiling nil nil (24 45 532 24 45 533 26 10 1 5 45 534 10 0 76 39 6 13 2 19 1 50 10 0 4 12 10 0 5 51 0 22 45 382 10 1 45 51 15 465 15 458 10 1 7 2 12 15 423 10 1 7 2 12 15 535 15 536 15 465 10 0 7 2 12 15 506 10 1 6 2 12 15 458 10 1 7 2 6 4 6 5 73 29) #1# #2# 18055) efficiency::*test-data* symbolic::infix->prefix ((symbolic::d (efficiency::a * efficiency::x symbolic::^ 2 + efficiency::b * efficiency::x + efficiency::c) / symbolic::d efficiency::x) (symbolic::d ((efficiency::a * efficiency::x symbolic::^ 2 + efficiency::b * efficiency::x + efficiency::c) / efficiency::x) / symbolic::d efficiency::x) (symbolic::d ((efficiency::a * efficiency::x symbolic::^ 3 + efficiency::b * efficiency::x symbolic::^ 2 + efficiency::c * efficiency::x + symbolic::d) / efficiency::x symbolic::^ 5) / symbolic::d efficiency::x) ((sin (efficiency::x + efficiency::x)) * (sin (2 * efficiency::x)) + (cos (symbolic::d (efficiency::x symbolic::^ 2) / symbolic::d efficiency::x)) symbolic::^ 1) (symbolic::d (3 * efficiency::x + (cos efficiency::x) / efficiency::x) / symbolic::d efficiency::x)) (defvar efficiency::*test-data*) (#2# . 18311) efficiency::*answers* symbolic::simplify (defvar efficiency::*answers*) (#2# . 18707) efficiency::test-it (defun efficiency::test-it) (#2# . 18761) (&optional (efficiency::with-profiling t)) #5=(symbolic::simplify symbolic::simplify-exp symbolic::variablep tools::match-variable tools::pat-match) (quote #5#) efficiency::answers efficiency::assert-equal mapc #Y(efficiency::test-it nil nil (25 40 3 14 55 46 528 26 10 0 39 71 33 413 12 15 551 19 2 141 14 391 15 552 19 2 467 52 391 33 396 12 14 391 15 551 19 2 432 52 391 12 19 2 141 75 52 480 64 10 33 544 12 14 538 19 2 141 65 15 551 19 1 506 33 413 12 15 551 19 2 141 14 391 15 552 19 2 467 52 391 66 45 553 33 554 12 13 0 14 543 19 3 555 11 55 73 43 1 29) #1# #2# 18761) "Time a test run and make sure the 
  answers are correct." (defun efficiency::assert-equal) (#2# . 19235) (efficiency::x efficiency::y) (equal efficiency::x efficiency::y) (efficiency::x efficiency::y) "Expected ~A to be equal to ~A" si::assert-failure #:g687 #:g688 #Y(efficiency::assert-equal nil nil (24 45 25 24 45 331 26 38 37 15 561 15 562 13 1 10 0 6 2 12 15 563 13 1 13 0 19 6 564 47 1 565 45 566 10 0 51 3 10 1 51 2 43 2 75 13 1 10 0 17 64 76 40 -44 73 29) #1# #2# 19235) "If x is not equal to y, complain.")) #2# 0) #Y(si::bytecodes nil nil (15 2 15 3 15 4 15 5 19 4 6 15 2 14 7 77 15 8 19 4 6 15 2 1 13 12 19 2 14 15 2 15 15 15 16 19 3 17 1 2 73 29) #1# #2# 117) #Y(si::bytecodes nil nil (15 18 15 3 15 19 15 20 19 4 6 15 18 14 7 77 15 21 19 4 6 15 18 34 32 12 19 2 14 15 18 15 15 15 33 19 3 17 1 18 73 29) #1# #2# 325) #Y(si::bytecodes nil nil (15 34 15 3 15 35 15 36 19 4 6 15 34 14 7 77 15 37 19 4 6 15 34 1 41 12 19 2 14 15 34 15 15 15 42 19 3 17 1 34 73 29) #1# #2# 668) #Y(si::bytecodes nil nil (15 43 15 3 15 44 15 45 19 4 6 15 43 14 7 77 15 46 19 4 6 15 43 1 54 12 14 55 9 3 19 4 14 15 43 15 15 15 56 19 3 17 1 43 73 29) #1# #2# 853) #Y(si::bytecodes nil nil (15 40 15 3 15 57 15 58 19 4 6 15 40 14 7 77 15 59 19 4 6 15 40 34 75 12 19 2 14 15 40 15 15 15 76 19 3 17 1 40 73 29) #1# #2# 968) #Y(si::bytecodes nil nil (15 52 15 3 15 77 15 78 19 4 6 15 52 14 7 77 15 79 19 4 6 15 52 1 83 12 19 2 14 15 52 15 15 15 84 19 3 17 1 52 73 29) #1# #2# 2065) #Y(si::bytecodes nil nil (15 85 15 3 15 86 15 87 19 4 6 15 85 14 7 77 15 88 19 4 6 15 85 1 90 12 19 2 14 15 85 15 15 15 91 19 3 17 1 85 73 29) #1# #2# 2494) #Y(si::bytecodes nil nil (15 92 15 3 15 93 15 94 19 4 6 15 92 14 7 77 15 95 19 4 6 15 92 1 96 12 19 2 14 15 92 15 15 15 97 19 3 17 1 92 73 29) #1# #2# 2723) #Y(si::bytecodes nil nil (15 98 15 3 15 99 15 100 19 4 6 15 98 14 7 77 15 101 19 4 6 15 98 1 104 12 19 2 14 15 98 15 15 15 105 19 3 17 1 98 73 29) #1# #2# 2804) #Y(si::bytecodes nil nil (15 103 15 3 15 106 15 107 19 4 6 15 103 14 7 77 15 108 19 4 6 15 103 1 113 12 19 2 14 15 103 15 15 15 114 19 3 17 1 103 73 29) #1# #2# 2919) #Y(si::bytecodes nil nil (15 115 15 3 15 116 15 117 19 4 6 15 115 14 7 77 15 118 19 4 6 15 115 1 127 12 19 2 14 15 115 15 15 15 128 19 3 17 1 115 73 29) #1# #2# 3038) #Y(si::bytecodes nil nil (15 126 15 3 15 129 15 130 19 4 6 15 126 14 7 77 15 131 19 4 6 15 126 1 134 12 19 2 14 15 126 15 15 15 135 19 3 17 1 126 73 29) #1# #2# 3437) #Y(si::bytecodes nil nil (15 124 15 3 15 136 15 137 19 4 6 15 124 14 7 77 15 138 19 4 6 15 124 1 142 12 19 2 14 15 124 15 15 15 143 19 3 17 1 124 73 29) #1# #2# 3666) #Y(si::bytecodes nil nil (15 144 15 3 15 145 15 146 19 4 6 15 144 14 7 77 15 147 19 4 6 15 144 1 151 12 14 55 9 1 19 4 14 15 144 15 15 15 152 19 3 17 1 144 73 29) #1# #2# 3870) #Y(si::bytecodes nil nil (15 153 15 154 77 77 15 155 15 156 15 157 77 77 77 15 158 9 2 77 77 15 159 19 15 160 15 153 15 3 15 161 15 162 19 4 6 15 163 15 3 15 164 15 165 19 4 6 15 163 14 7 77 15 166 19 4 6 15 153 19 1 173 78 170 15 163 1 172 12 19 2 14 1 174 16 175 45 176 10 0 39 10 10 0 16 177 39 4 11 178 76 39 16 15 179 15 180 15 181 15 182 14 183 13 0 19 6 184 43 1 15 174 15 185 1 193 12 19 3 194 1 195 16 175 45 176 10 0 39 10 10 0 16 177 39 4 11 178 76 39 16 15 179 15 180 15 181 15 196 14 183 13 0 19 6 184 43 1 15 195 15 185 1 198 12 19 3 194 1 153 73 29) #1# #2# 4314) #Y(si::bytecodes nil nil (15 153 15 3 15 199 15 200 19 4 6 15 153 14 7 77 15 201 19 4 6 15 153 1 207 12 14 55 9 1 19 4 14 15 153 15 15 15 208 19 3 17 1 153 73 29) #1# #2# 5474) #Y(si::bytecodes nil nil (15 209 15 3 15 210 15 211 19 4 6 15 209 14 7 77 15 212 19 4 6 15 209 1 218 12 19 2 14 15 209 15 15 15 219 19 3 17 1 209 73 29) #1# #2# 5632) #Y(si::bytecodes nil nil (15 220 15 3 15 221 15 222 19 4 6 15 220 14 7 77 15 223 19 4 6 15 220 1 231 12 14 55 9 3 19 4 14 15 220 15 15 15 232 19 3 17 1 220 73 29) #1# #2# 5914) #Y(si::bytecodes nil nil (15 233 75 17 234 15 233 15 3 15 235 15 236 19 4 6 1 233 73 29) #1# #2# 6347) #Y(si::bytecodes nil nil (15 227 15 3 15 237 15 238 19 4 6 15 227 14 7 77 15 239 19 4 6 15 227 1 241 12 19 2 14 1 227 73 29) #1# #2# 6379) #Y(si::bytecodes nil nil (15 242 15 3 15 243 15 244 19 4 6 15 242 14 7 77 15 245 19 4 6 15 242 1 246 12 19 2 14 1 242 73 29) #1# #2# 6415) #Y(si::bytecodes nil nil (15 247 15 3 15 248 15 249 19 4 6 15 247 14 7 77 15 250 19 4 6 15 247 1 254 12 19 2 14 15 247 15 15 15 255 19 3 17 1 247 73 29) #1# #2# 6463) #Y(si::bytecodes nil nil (15 256 15 3 15 257 15 258 19 4 6 15 256 14 7 77 15 259 19 4 6 15 256 1 263 12 19 2 14 15 256 15 15 15 264 19 3 17 1 256 73 29) #1# #2# 6601) #Y(si::bytecodes nil nil (15 262 15 3 15 265 15 266 19 4 6 15 262 14 7 77 15 267 19 4 6 15 262 1 271 12 14 55 9 3 19 4 14 15 262 15 15 15 272 19 3 17 1 262 73 29) #1# #2# 6961) #Y(si::bytecodes nil nil (15 228 15 3 15 273 15 274 19 4 6 15 228 14 7 77 15 275 19 4 6 15 228 1 280 12 19 2 14 15 228 15 15 15 281 19 3 17 1 228 73 29) #1# #2# 8062) #Y(si::bytecodes nil nil (15 282 15 3 15 283 15 284 19 4 6 15 282 14 7 77 15 285 19 4 6 15 282 1 292 12 19 2 14 15 282 15 15 15 293 19 3 17 1 282 73 29) #1# #2# 8289) #Y(si::bytecodes nil nil (15 294 15 3 15 295 15 296 19 4 6 15 294 14 7 77 15 297 19 4 6 15 294 34 300 12 19 2 14 15 294 15 15 15 301 19 3 17 1 294 73 29) #1# #2# 9248) #Y(si::bytecodes nil nil (15 302 15 3 15 303 15 304 19 4 6 15 302 14 7 77 15 305 19 4 6 15 302 34 310 12 19 2 14 1 302 73 29) #1# #2# 9565) #Y(si::bytecodes nil nil (1 311 16 312 1 311 16 313 76 39 4 75 52 311 15 311 15 3 15 314 15 315 19 4 6 1 311 73 29) #1# #2# 9750) #Y(si::bytecodes nil nil (15 316 15 3 15 317 15 318 19 4 6 15 316 14 7 77 77 19 4 6 15 316 1 319 12 19 2 14 1 316 73 29) #1# #2# 10050) #Y(si::bytecodes nil nil (15 320 15 3 15 321 15 322 19 4 6 15 320 14 7 77 15 323 19 4 6 15 320 34 325 12 19 2 14 15 320 15 15 15 326 19 3 17 1 320 73 29) #1# #2# 10121) #Y(si::bytecodes nil nil (15 327 15 3 15 328 15 329 19 4 6 15 327 14 7 77 15 330 19 4 6 15 327 34 333 12 19 2 14 15 327 15 15 15 334 19 3 17 1 327 73 29) #1# #2# 10773) #Y(si::bytecodes nil nil (15 335 15 3 15 336 15 337 19 4 6 15 335 14 7 77 15 338 19 4 6 15 335 34 340 12 19 2 14 15 335 15 15 15 341 19 3 17 1 335 73 29) #1# #2# 11056) #Y(si::bytecodes nil nil (15 342 15 3 15 343 15 344 19 4 6 15 342 14 7 77 15 345 19 4 6 15 342 1 353 12 19 2 14 15 342 15 15 15 354 19 3 17 1 342 73 29) #1# #2# 11510) #Y(si::bytecodes nil nil (15 355 15 3 15 356 15 357 19 4 6 15 355 14 7 77 15 358 19 4 6 15 355 1 361 12 19 2 14 15 355 15 15 15 362 19 3 17 1 355 73 29) #1# #2# 12487) #Y(si::bytecodes nil nil (15 363 15 3 15 364 15 365 19 4 6 15 363 14 7 77 15 366 19 4 6 15 363 34 371 12 19 2 14 15 363 15 15 15 372 19 3 17 1 363 73 29) #1# #2# 12808) #Y(si::bytecodes nil nil (15 373 15 3 15 374 15 375 19 4 6 15 373 14 7 77 15 376 19 4 6 15 373 1 377 12 19 2 14 1 373 73 29) #1# #2# 12989) #Y(si::bytecodes nil nil (15 378 15 3 15 379 15 380 19 4 6 15 378 14 7 77 15 381 19 4 6 15 378 1 389 12 19 2 14 15 378 15 15 15 390 19 3 17 1 378 73 29) #1# #2# 13053) #Y(si::bytecodes nil nil (1 391 16 312 1 391 16 313 76 39 4 75 52 391 15 391 15 392 15 393 19 3 17 15 391 15 3 15 394 15 395 19 4 6 1 391 73 29) #1# #2# 13387) #Y(si::bytecodes nil nil (15 396 15 3 15 397 15 398 19 4 6 15 396 14 7 77 15 399 19 4 6 15 396 1 411 12 19 2 14 15 396 15 15 15 412 19 3 17 1 396 73 29) #1# #2# 13921) #Y(si::bytecodes nil nil (15 413 15 3 15 414 15 415 19 4 6 15 413 14 7 77 15 416 19 4 6 15 413 1 421 12 19 2 14 15 413 15 15 15 422 19 3 17 1 413 73 29) #1# #2# 14593) #Y(si::bytecodes nil nil (15 423 15 3 15 424 15 425 19 4 6 15 423 14 7 77 15 426 19 4 6 15 423 1 433 12 14 55 9 1 19 4 14 15 423 15 15 15 434 19 3 17 1 423 73 29) #1# #2# 14975) #Y(si::bytecodes nil nil (15 435 15 3 15 436 15 437 19 4 6 15 435 14 7 77 77 19 4 6 15 435 1 439 12 19 2 14 15 435 15 15 15 440 19 3 17 1 435 73 29) #1# #2# 15226) #Y(si::bytecodes nil nil (15 441 15 3 15 442 15 443 19 4 6 15 441 14 7 77 15 444 19 4 6 15 441 1 445 12 19 2 14 15 441 15 15 15 446 19 3 17 1 441 73 29) #1# #2# 15308) #Y(si::bytecodes nil nil (15 447 15 3 15 448 15 449 19 4 6 15 447 14 7 77 15 450 19 4 6 15 447 1 456 12 19 2 14 15 447 15 15 15 457 19 3 17 1 447 73 29) #1# #2# 15398) #Y(si::bytecodes nil nil (15 458 15 3 15 459 15 460 19 4 6 15 458 14 7 77 15 461 19 4 6 15 458 1 468 12 14 55 9 1 19 4 14 15 458 15 15 15 469 19 3 17 1 458 73 29) #1# #2# 15546) #Y(si::bytecodes nil nil (1 470 16 471 29) #1# #2# 15943) #Y(si::bytecodes nil nil (15 352 15 3 15 472 15 473 19 4 6 15 352 14 7 77 15 474 19 4 6 15 352 34 478 12 19 2 14 15 352 15 15 15 479 19 3 17 1 352 73 29) #1# #2# 16060) #Y(si::bytecodes nil nil (1 480 16 312 1 480 16 313 76 39 4 75 52 480 15 480 15 3 15 481 15 482 19 4 6 1 480 73 29) #1# #2# 16295) #Y(si::bytecodes nil nil (15 475 15 3 15 483 15 484 19 4 6 15 475 14 7 77 15 485 19 4 6 15 475 1 490 12 19 2 14 1 475 73 29) #1# #2# 16330) #Y(si::bytecodes nil nil (15 476 15 3 15 491 15 492 19 4 6 15 476 14 7 77 15 493 19 4 6 15 476 1 497 12 19 2 14 1 476 73 29) #1# #2# 16693) #Y(si::bytecodes nil nil (15 489 15 3 15 498 15 499 19 4 6 15 489 14 7 77 15 500 19 4 6 15 489 1 505 12 19 2 14 1 489 73 29) #1# #2# 17010) #Y(si::bytecodes nil nil (15 506 15 3 15 507 15 508 19 4 6 15 506 14 7 77 15 509 19 4 6 15 506 1 522 12 19 2 14 15 506 15 15 15 523 19 3 17 1 506 73 29) #1# #2# 17157) #Y(si::bytecodes nil nil (15 511 15 3 15 524 15 525 19 4 6 15 511 14 7 77 15 526 19 4 6 15 511 1 527 12 19 2 14 1 511 73 29) #1# #2# 17993) #Y(si::bytecodes nil nil (15 528 15 3 15 529 15 530 19 4 6 15 528 14 7 77 15 531 19 4 6 15 528 1 537 12 14 55 9 2 19 4 14 1 528 73 29) #1# #2# 18055) #Y(si::bytecodes nil nil (1 538 16 312 1 538 16 313 76 39 11 33 539 12 15 540 19 2 141 52 538 15 538 15 3 15 541 15 542 19 4 6 1 538 73 29) #1# #2# 18311) #Y(si::bytecodes nil nil (1 543 16 312 1 543 16 313 76 39 11 33 544 12 14 538 19 2 141 52 543 15 543 15 3 15 545 15 546 19 4 6 1 543 73 29) #1# #2# 18707) #Y(si::bytecodes nil nil (15 547 15 3 15 548 15 549 19 4 6 15 547 14 7 77 15 550 19 4 6 15 547 1 556 12 19 2 14 15 547 15 15 15 557 19 3 17 1 547 73 29) #1# #2# 18761) #Y(si::bytecodes nil nil (15 554 15 3 15 558 15 559 19 4 6 15 554 14 7 77 15 560 19 4 6 15 554 1 567 12 19 2 14 15 554 15 15 15 568 19 3 17 1 554 73 29) #1# #2# 19235))
