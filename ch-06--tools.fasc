(#Y(si::bytecodes nil nil (1 0 16 1 29) #1=#A(t (840) ("TOOLS" si::select-package tools::?[ si::*make-special ext::location (defparameter tools::?[) (#2=#P"/data/data/org.eql5.android.repl/files/quicklisp/local-projects/paip/ch-06--tools.lisp" . 127) ext::annotate tools::?] (defparameter tools::?]) (#2# . 163) tools::interactive-interpreter (defun tools::interactive-interpreter) (#2# . 186) :lambda-list (tools::prompt tools::transformer &key (tools::safe t) (tools::quit (quote #3=("q" "quit" "exit"))) (stream *query-io*)) tools::prompt tools::transformer (nil :stream :quit :safe) t tools::safe #3# tools::quit *query-io* stream alexandria::ensure-list *standard-output* 0 #:g252 #:g253 error si::temp #Y(nil nil nil (24 45 31 26 10 0 51 2 35 1 0 29) #1# #2# 186) si::*handler-clusters* stringp print read-line tools::line uiop/utility::split-string tools::split si::%dolist-var tools::q :test equalp member tools::done uiop/stream::safe-read-from-string read-from-string condition "~&;; Error~%~A~%Ignored." format #Y(tools::interactive-interpreter nil nil (24 45 16 24 45 17 28 18 22 40 3 14 19 46 20 22 40 3 15 21 46 22 22 40 3 14 23 46 24 57 11 60 179 13 2 19 1 25 12 13 1 49 26 46 22 57 27 61 1 1 57 28 60 148 75 45 29 57 27 61 1 119 15 30 34 32 3 6 1 12 11 33 3 48 33 10 10 16 34 39 8 13 10 19 1 35 38 6 13 10 20 0 23 19 0 36 45 37 13 0 19 1 38 45 39 10 6 45 40 38 32 10 0 4 45 41 13 0 13 2 14 42 33 43 12 19 4 44 39 6 1 45 73 36 9 10 1 5 51 1 43 1 10 0 40 -34 43 1 13 11 10 10 39 8 13 1 19 1 46 38 6 13 1 19 1 47 12 20 1 23 12 19 1 35 43 2 36 2 44 1 10 1 45 48 14 19 15 49 13 0 19 3 50 43 1 36 2 62 43 1 63 35 0 0 62 73 43 1 44 1 63 29) #1# #2# 186) si::fset function "interactive-interpreter
       (prompt transformer &key safe
        quit stream) -> 'DONE
     prompt: string or function
     transformer: function
     safe: generalized Boolean. default t.
     quit: string or list of strings.
           default: (``q'' ``quit'' ``exit'')
     stream: stream object. default: *query-io*.
     
    Interactive program loop. On each
    loop, if prompt is a string, it is
    printed to stream. Otherwise, it must
    be a function of no args that 
    will be called at that time. 
    A line from the user is read
    into a string. If the string contains
    the quit string, or one of the quit 
    strings, the loop is exited and DONE
    is returned. Otherwise, the first
    form is read from the string--with safe
    io syntax if safe is t--and the result
    of invoking transformer on form
    is printed to stream. The rest of the
    line is discarded. If an error occurs, 
    the error message is printed to stream,
    and the loop continues." si::set-documentation tools::prompt-generator (defun tools::prompt-generator) (#2# . 2164) (&optional (tools::num 0) (tools::control #4="[~D] ")) tools::num #4# tools::control #:g258 + #Y(nil nil nil (26 14 19 13 0 8 1 45 63 13 2 13 0 19 2 64 51 2 12 43 1 19 3 50 29) #1# #2# 2164) #Y(tools::prompt-generator nil nil (25 40 3 9 0 46 60 25 40 3 15 61 46 62 26 34 65 73 29) #1# #2# 2164) "Return a function that prints prompts
  like [1], [2], etc." tools::+fail+ si::*make-constant variable "Indicates pat-match failure." (defconstant tools::+fail+) (#2# . 2390) tools::+no-bindings+ ((t . t)) "Indicates pat-match success, with no
  variables." (defconstant tools::+no-bindings+) (#2# . 3924) tools::variablep (defun tools::variablep) (#2# . 4018) (tools::x) tools::x symbolp symbol-name char #\? eql #Y(tools::variablep nil nil (24 45 83 26 10 0 16 84 73 39 15 10 0 16 85 12 8 0 17 86 12 1 87 17 88 29) #1# #2# 4018) "Is x a variable, i.e., a symbol 
  beginning with ``?'' ?" tools::get-binding (defun tools::get-binding) (#2# . 4199) (tools::var tools::bindings) tools::var tools::bindings assoc #Y(tools::get-binding nil nil (24 45 95 24 45 96 26 13 1 13 0 19 2 97 29) #1# #2# 4199) "Find a (variable . binding) pair 
  in a binding list." tools::binding-var (defun tools::binding-var) (#2# . 4317) (tools::binding) tools::binding #Y(tools::binding-var nil nil (24 45 104 26 10 0 4 73 29) #1# #2# 4317) "Get the variable part of a single
  binding." tools::binding-val (defun tools::binding-val) (#2# . 4413) (tools::binding) #Y(tools::binding-val nil nil (24 45 104 26 10 0 5 73 29) #1# #2# 4413) "Get the value part of a single
  binding." tools::make-binding (defun tools::make-binding) (#2# . 4506) (tools::var tools::val) tools::val #Y(tools::make-binding nil nil (24 45 95 24 45 117 26 13 1 10 0 3 73 29) #1# #2# 4506) tools::lookup (defun tools::lookup) (#2# . 4555) (tools::var tools::bindings) #Y(tools::lookup nil nil (24 45 95 24 45 96 26 13 1 13 0 19 2 91 12 19 1 107 29) #1# #2# 4555) "Get the value part (for var) from a
  binding list." tools::extend-bindings (defun tools::extend-bindings) (#2# . 4685) (tools::var tools::val tools::bindings) tree-equal #Y(tools::extend-bindings nil nil (24 45 95 24 45 117 24 45 96 26 13 2 13 1 19 2 113 12 13 0 14 74 19 2 129 39 4 75 38 3 10 0 3 73 29) #1# #2# 4685) "Add a (variable . value) pair to a 
  binding list." tools::match-variable (defun tools::match-variable) (#2# . 4967) (tools::var tools::input tools::bindings) tools::input equal #Y(tools::match-variable nil nil (24 45 95 24 45 136 24 45 96 26 13 2 13 0 19 2 91 45 104 10 0 39 22 13 2 13 0 19 1 107 17 137 39 6 10 1 73 38 4 11 68 73 38 10 13 3 13 2 13 1 19 3 125 43 1 29) #1# #2# 4967) "Does var match input? Uses (or updates)
  and returns bindings." tools::pat-match (defun tools::pat-match) (#2# . 5301) (tools::pattern tools::input &optional (tools::bindings tools::+no-bindings+) (tools::var? (function tools::variablep))) tools::pattern tools::var? eq consp tools::literal-match tools::new-bindings tools::rest-input tools::rest-pattern tools::segment-pattern-p tools::segment-matcher tools::single-pattern-p tools::single-matcher #Y(tools::pat-match nil nil (24 45 144 24 45 136 25 40 3 14 74 46 96 25 40 4 33 79 12 46 145 26 13 1 11 68 17 146 39 6 11 68 73 38 213 13 0 13 3 20 1 23 39 12 13 3 13 2 13 1 19 3 132 38 193 13 3 10 2 17 88 39 6 10 1 73 38 180 10 3 16 147 39 9 10 3 4 12 11 2 17 146 39 78 10 3 5 12 13 2 13 1 19 3 148 47 2 149 47 1 150 45 151 13 2 11 68 17 146 39 6 11 68 73 38 42 10 0 76 39 4 10 1 76 39 6 10 2 73 38 27 10 0 76 40 4 10 1 76 39 6 11 68 73 38 12 13 0 13 1 13 2 13 3 19 4 140 43 3 38 87 13 3 19 1 152 39 14 13 3 13 2 13 1 13 0 19 4 153 38 67 13 3 19 1 154 39 14 13 3 13 2 13 1 13 0 19 4 155 38 47 10 3 16 147 39 5 10 2 16 147 39 32 10 3 5 12 10 2 5 12 10 3 4 12 10 2 4 12 13 1 13 0 19 4 140 12 13 0 19 4 140 38 4 11 68 73 29) #1# #2# 5301) "Match pattern against input in the 
  context of the bindings." tools::?is #:g259 tools::single-match #:g260 tools::match-is #:g261 si::putprop tools::?or #:g262 #:g263 tools::match-or #:g264 tools::?and #:g265 #:g266 tools::match-and #:g267 tools::?not #:g268 #:g269 tools::match-not #:g270 tools::?* #:g271 tools::segment-match #:g272 #:g273 tools::?+ #:g274 #:g275 tools::segment-match+ #:g276 tools::?? #:g277 #:g278 tools::segment-match? #:g279 tools::?if #:g280 #:g281 tools::match-if #:g282 (defun tools::segment-pattern-p) (#2# . 7070) (tools::pattern) tools::segment-match-fn #Y(tools::segment-pattern-p nil nil (24 45 144 26 10 0 16 147 73 39 26 10 0 4 16 147 73 39 18 10 0 4 4 16 84 73 39 9 10 0 4 4 12 19 1 203 29) #1# #2# 7070) "Is this a segment matching pattern, 
  like ((:* var) . pat) ?" (defun tools::single-pattern-p) (#2# . 7330) (tools::pattern) tools::single-match-fn #Y(tools::single-pattern-p nil nil (24 45 144 26 10 0 16 147 73 39 8 10 0 4 12 19 1 209 29) #1# #2# 7330) "Is this a single-matching pattern?
  E.g., (:is x predicate) (:and . patterns)
  (:or . patterns)" (defun tools::segment-matcher) (#2# . 7533) (tools::pattern tools::input tools::bindings tools::var?) #Y(tools::segment-matcher nil nil (24 45 144 24 45 136 24 45 96 24 45 145 26 10 3 4 4 12 19 1 203 12 13 3 13 2 13 1 13 0 20 4 23 29) #1# #2# 7533) "Call the right function for this type
  of segment pattern." (defun tools::single-matcher) (#2# . 7795) (tools::pattern tools::input tools::bindings tools::var?) #Y(tools::single-matcher nil nil (24 45 144 24 45 136 24 45 96 24 45 145 26 10 3 4 12 19 1 209 12 10 3 5 12 13 2 13 1 13 0 20 4 23 29) #1# #2# 7795) "Call the right function for this type 
  of single pattern." (defun tools::segment-match-fn) (#2# . 8013) (tools::x) get #Y(tools::segment-match-fn nil nil (24 45 83 26 10 0 16 84 73 39 8 13 0 15 182 19 2 225 29) #1# #2# 8013) "Get the segment match function for x,
  if it is a symbol that has one." (defun tools::single-match-fn) (#2# . 8167) (tools::x) #Y(tools::single-match-fn nil nil (24 45 83 26 10 0 16 84 73 39 8 13 0 15 160 19 2 225 29) #1# #2# 8167) "Get the single match function for x,
  if it is a symbol that has one." (defun tools::match-is) (#2# . 8318) (tools::var-and-pred tools::input tools::bindings tools::var?) tools::var-and-pred second tools::pred #Y(tools::match-is nil nil (24 45 236 24 45 136 24 45 96 24 45 145 26 10 3 4 45 95 10 4 16 237 45 238 13 1 13 4 13 3 13 2 19 4 140 45 149 13 0 11 68 17 146 40 9 13 1 13 5 20 1 23 76 39 6 11 68 73 38 4 10 0 73 43 3 29) #1# #2# 8318) "Succeed and bind var if the input 
  satisfies pred, where var-and-pred is 
  the list (var pred)." (defun tools::match-and) (#2# . 8736) (tools::patterns tools::input tools::bindings tools::var?) tools::patterns #Y(tools::match-and nil nil (24 45 244 24 45 136 24 45 96 24 45 145 26 13 1 11 68 17 146 39 6 11 68 73 38 36 10 3 76 39 6 10 1 73 38 26 10 3 5 12 13 2 10 3 4 12 13 2 13 1 13 0 19 4 140 12 13 0 19 4 173 29) #1# #2# 8736) "Succeed if all the patterns match the
  input." (defun tools::match-or) (#2# . 9069) (tools::patterns tools::input tools::bindings tools::var?) #Y(tools::match-or nil nil (24 45 244 24 45 136 24 45 96 24 45 145 26 10 3 76 39 6 11 68 73 38 44 10 3 4 12 13 2 13 1 13 0 19 4 140 45 149 13 0 11 68 17 146 39 16 10 4 5 12 13 3 13 2 13 1 19 4 168 38 4 10 0 73 43 1 29) #1# #2# 9069) "Succeed if any one of the patterns 
  matches the input." (defun tools::segment-match) (#2# . 9546) (tools::pattern tools::input tools::bindings tools::var? &optional (tools::start 0)) tools::start tools::pat tools::first-match-pos tools::pos subseq tools::b2 1+ #Y(tools::segment-match nil nil (24 45 144 24 45 136 24 45 96 24 45 145 25 40 3 9 0 46 255 26 10 4 4 16 237 12 10 4 5 12 46 256 46 95 10 1 76 39 12 13 0 13 5 13 4 19 3 132 38 94 10 1 4 12 13 5 13 2 13 3 19 4 257 45 258 10 0 76 39 6 11 68 73 38 67 13 2 13 6 13 0 19 2 259 12 13 1 13 6 9 0 13 0 19 3 259 12 13 5 19 3 132 12 13 4 19 4 140 45 260 13 0 11 68 17 146 39 19 13 8 13 7 13 6 13 5 10 1 16 261 12 19 5 182 38 4 10 0 73 43 1 43 1 43 2 29) #1# #2# 9546) "Match the segment pattern ((:* var) . pat)
  against the input." (defun tools::first-match-pos) (#2# . 10743) (tools::pat1 tools::input tools::start tools::var?) tools::pat1 atom :start position length < #Y(tools::first-match-pos nil nil (24 45 267 24 45 136 24 45 255 24 45 145 26 10 3 16 268 39 9 13 0 13 3 20 1 23 76 39 19 13 3 13 2 14 269 13 1 14 42 33 137 12 19 6 270 38 20 13 1 10 2 16 271 12 19 2 272 39 6 10 1 73 38 3 75 73 29) #1# #2# 10743) "Find the first position that pat1 could
  possibly match input, starting at 
  position start. If pat1 is non-constant,
  then just return start." (defun tools::segment-match+) (#2# . 11137) (tools::pattern tools::input tools::bindings tools::var?) #Y(tools::segment-match+ nil nil (24 45 144 24 45 136 24 45 96 24 45 145 26 13 3 13 2 13 1 13 0 9 1 19 5 182 29) #1# #2# 11137) "Match one or more elements of input." (defun tools::segment-match?) (#2# . 11949) (tools::pattern tools::input tools::bindings tools::var?) #Y(tools::segment-match? nil nil (24 45 144 24 45 136 24 45 96 24 45 145 26 10 3 4 16 237 12 10 3 5 12 46 256 46 95 13 0 10 1 3 12 13 4 13 3 13 2 19 4 140 73 40 12 13 1 13 4 13 3 13 2 19 4 140 43 2 29) #1# #2# 11949) "Match 0 or 1 elements of input." (defun tools::match-if) (#2# . 12211) (tools::pattern tools::input tools::bindings tools::var?) car mapcar cdr eval #Y(tools::match-if nil nil (24 45 144 24 45 136 24 45 96 24 45 145 26 33 288 12 13 1 19 2 289 12 33 290 12 13 1 19 2 289 67 10 3 4 16 237 16 291 68 73 39 14 10 3 5 12 13 2 13 1 13 0 19 4 140 29) #1# #2# 12211) "Test an arbitrary Lisp expression
  using variables. The pattern looks like
  ((:if <code>) . <rest>)." (defun tools::literal-match) (#2# . 12531) (tools::pattern tools::input tools::bindings) #Y(tools::literal-match nil nil (24 45 144 24 45 136 24 45 96 26 13 0 11 68 17 146 39 11 13 2 13 1 14 68 72 3 38 134 10 2 76 40 4 10 1 76 39 11 13 2 13 1 13 0 72 3 38 114 10 2 4 12 11 8 17 146 39 13 10 2 5 12 13 1 13 0 72 3 38 92 10 2 4 16 147 39 6 10 1 4 16 147 39 44 10 2 4 12 10 1 4 12 14 42 33 137 12 19 4 129 39 16 10 2 5 12 10 1 5 12 13 0 19 3 148 38 9 13 2 13 1 14 68 72 3 38 35 10 2 4 12 10 1 4 17 137 39 16 10 2 5 12 10 1 5 12 13 0 19 3 148 38 9 13 2 13 1 14 68 72 3 29) #1# #2# 12531) tools::pat-match-abbrev (defun tools::pat-match-abbrev) (#2# . 13423) (symbol tools::expansion) symbol tools::expansion #:g286 tools::expand-pat-match-abbrev #:g287 #:g288 #Y(tools::pat-match-abbrev nil nil (24 45 302 24 45 303 26 10 1 45 304 1 305 45 306 13 2 19 1 305 45 307 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 13423) "Define symbol as a macro standing for 
  a pat-match pattern." (defun tools::expand-pat-match-abbrev) (#2# . 14276) (tools::pat) tools::*escaped* tools::subpat #Y(tools::rec nil nil (24 45 314 26 13 0 11 2 17 88 39 8 11 19 52 313 73 38 66 13 0 11 8 17 88 39 7 75 52 313 73 38 52 11 313 76 39 14 10 0 16 84 39 8 13 0 15 305 19 2 225 73 40 31 10 0 16 268 39 6 10 0 73 38 20 10 0 4 12 32 1 18 1 12 10 0 5 12 32 1 18 1 3 73 29) #1# #2# 14276) #Y(tools::expand-pat-match-abbrev nil nil (24 45 256 26 75 48 313 31 1 315 13 1 32 0 18 1 43 1 44 1 29) #1# #2# 14276) "Expand out all pattern-matching 
  abbreviations in pat." tools::rule-based-translator (defun tools::rule-based-translator) (#2# . 15005) (tools::input tools::rules &key (tools::matcher (function tools::pat-match)) (tools::rule-if (function first)) (tools::rule-then (function rest)) (tools::action (function sublis)) (tools::var? (function tools::variablep))) tools::rules (nil :var? :action :rule-then :rule-if :matcher) tools::matcher first tools::rule-if rest tools::rule-then sublis tools::action tools::rule tools::result #Y(nil nil nil (24 45 331 26 13 5 13 4 13 0 20 1 23 12 13 7 14 74 13 1 20 4 23 45 332 13 0 11 68 17 146 76 73 39 16 13 3 13 0 13 4 13 1 20 1 23 12 20 2 23 43 1 29) #1# #2# 15005) some #Y(tools::rule-based-translator nil nil (24 45 136 24 45 322 28 323 22 40 4 33 140 12 46 324 22 40 4 33 325 12 46 326 22 40 4 33 327 12 46 328 22 40 4 33 329 12 46 330 22 40 4 33 79 12 46 145 34 333 12 13 5 19 2 334 29) #1# #2# 15005) "Find the first rule in rules that matches
  input, and apply the action to that rule." tools::tree-search (defun tools::tree-search) (#2# . 16012) (tools::states tools::goalp tools::successors tools::combiner) tools::states tools::goalp tools::successors tools::combiner :search "~&;; Search: ~A" general-problem-solver::dbg #Y(tools::tree-search nil nil (24 45 341 24 45 342 24 45 343 24 45 344 26 14 345 15 346 13 3 19 3 347 10 3 76 39 6 11 68 73 38 47 13 2 10 3 4 12 20 1 23 39 7 10 3 4 73 38 30 13 0 13 1 10 3 4 12 20 1 23 12 10 3 5 12 20 2 23 12 13 2 13 1 13 0 19 4 337 29) #1# #2# 16012) "tree-search 
    (states goalp successors combiner) -> obj
  states: list
  goalp: predicate function
  successors: function
  combiner: function.
  Find a state that satisfies goalp. Start
  with states and search according to 
  successors and combiner." tools::depth-first-search (defun tools::depth-first-search) (#2# . 17147) (tools::start tools::goalp tools::successors) append #Y(tools::depth-first-search nil nil (24 45 255 24 45 342 24 45 343 26 10 2 6 1 12 13 1 13 0 33 354 12 19 4 337 29) #1# #2# 17147) "Search new states first until goal is
  reached." tools::binary-tree (defun tools::binary-tree) (#2# . 17334) (tools::x) * #Y(tools::binary-tree nil nil (24 45 83 26 9 2 13 0 19 2 361 12 9 2 13 0 19 2 361 16 261 6 2 73 29) #1# #2# 17334) "Helper function for building a 
  binary tree of integers which can
  be called recursively to produce the
  elements (node indices) of the tree.
  Takes a single number to serve as a 
  local root." tools::is (defun tools::is) (#2# . 17607) (tools::value) tools::value #Y(nil nil nil (24 45 83 26 13 0 10 1 17 88 29) #1# #2# 17607) #Y(tools::is nil nil (24 45 368 26 34 369 73 29) #1# #2# 17607) "Takes value and returns a function of
  one arg that checks the arg for equality
  with value. Uses EQL, so value must be 
  a symbol, number or character. With
  numbers, returns T only if the number
  has the same value and type. With 
  characters, the two compared characters
  must have the same character code--so
  the test is case sensitive." tools::prepend (defun tools::prepend) (#2# . 18015) (tools::x tools::y) tools::y #Y(tools::prepend nil nil (24 45 83 24 45 376 26 13 0 13 1 19 2 354 29) #1# #2# 18015) "Prepend y to start of x." tools::breadth-first-search (defun tools::breadth-first-search) (#2# . 18408) (tools::start tools::goalp tools::successors) #Y(tools::breadth-first-search nil nil (24 45 255 24 45 342 24 45 343 26 10 2 6 1 12 13 1 13 0 33 372 12 19 4 337 29) #1# #2# 18408) "Search old states first until goal
  is reached." tools::finite-binary-tree (defun tools::finite-binary-tree) (#2# . 18589) (tools::n) tools::n tools::child > #Y(nil nil nil (24 45 390 26 13 0 13 2 19 2 391 29) #1# #2# 18589) remove-if #Y(nil nil nil (24 45 83 26 34 392 12 13 0 19 1 357 12 19 2 393 29) #1# #2# 18589) #Y(tools::finite-binary-tree nil nil (24 45 389 26 34 394 73 29) #1# #2# 18589) "Return a successor function that 
  generates a binary tree with n nodes." tools::diff (defun tools::diff) (#2# . 19317) (tools::num) - abs #Y(nil nil nil (24 45 83 26 13 0 13 1 19 2 401 16 402 29) #1# #2# 19317) #Y(tools::diff nil nil (24 45 60 26 34 403 73 29) #1# #2# 19317) "Return the function that finds the 
  difference from num." tools::sorter% (defun tools::sorter%) (#2# . 19720) (tools::cost-fn) tools::cost-fn tools::new tools::old :key sort #Y(nil nil nil (24 45 411 24 45 412 26 13 1 13 0 19 2 354 12 33 272 12 14 413 13 2 19 4 414 29) #1# #2# 19720) #Y(tools::sorter% nil nil (24 45 410 26 34 415 73 29) #1# #2# 19720) "Return a combiner function that sorts
  according to cost-fn." tools::best-first-search (defun tools::best-first-search) (#2# . 19911) (tools::start tools::goalp tools::successors tools::cost-fn) tools::sorter #Y(tools::best-first-search nil nil (24 45 255 24 45 342 24 45 343 24 45 410 26 10 3 6 1 12 13 2 13 1 13 0 19 1 422 12 19 4 337 29) #1# #2# 19911) "Search lowest cost states first until
  goal is reached." tools::price-is-right (defun tools::price-is-right) (#2# . 20115) (tools::price) tools::price most-positive-fixnum #Y(nil nil nil (24 45 83 26 13 0 13 1 19 2 391 39 6 11 430 73 38 8 13 1 13 0 19 2 401 29) #1# #2# 20115) #Y(tools::price-is-right nil nil (24 45 429 26 34 431 73 29) #1# #2# 20115) "Return a function that measures the 
  difference from price, but gives a big 
  penalty for going over price." tools::beam-search (defun tools::beam-search) (#2# . 20544) (tools::start tools::goalp tools::successors tools::cost-fn tools::beam-width) tools::beam-width tools::sorted >= #Y(nil nil nil (24 45 412 24 45 411 26 13 3 19 1 422 12 13 1 13 0 20 2 23 45 439 13 3 10 0 16 271 12 19 2 440 39 6 10 0 73 38 10 13 0 9 0 13 3 19 3 259 43 1 29) #1# #2# 20544) #Y(tools::beam-search nil nil (24 45 255 24 45 342 24 45 343 24 45 410 24 45 438 26 10 4 6 1 12 13 3 13 2 34 441 12 19 4 337 29) #1# #2# 20544) "Search highest scoring states first
  until goal is reached, but never consider
  more than beam-width states at a time." tools::city "CITY-" list (tools::name tools::long tools::lat) ((tools::name nil t nil 0 nil) (tools::long nil t nil 1 nil) (tools::lat nil t nil 2 nil)) tools::copy-city (tools::make-city) si::define-structure #5=(tools::city (:type list)) (defstruct #5#) (#2# . 21377) tools::make-city (defun tools::make-city) (#2# . 21377) (&key #6=#:name #7=#:long #8=#:lat) (nil :lat :long :name) #6# #7# #8# #Y(tools::make-city nil nil (28 459 22 40 2 77 46 460 22 40 2 77 46 461 22 40 2 77 46 462 13 2 13 1 10 0 6 3 73 29) #1# #2# 21377) tools::*cities* ((tools::atlanta 84.23 33.45) (tools::boston 71.05 42.21) (tools::chicago 87.37 41.5) (tools::denver 105.0 39.45) (tools::eugene 123.05 44.03) (tools::flagstaff 111.41 35.13) (tools::grand-jet 108.37 39.05) (tools::houston 105.0 34.0) (tools::indianapolis 86.1 39.46) (tools::jacksonville 81.4 30.22) (tools::kansas-city 94.35 39.06) (tools::los-angeles 118.15 34.03) (tools::memphis 90.03 35.09) (tools::new-york 73.58 40.47) (tools::oklahoma-city 97.28 35.26) (tools::pittsburgh 79.57 40.27) (tools::quebec 71.11 46.49) (tools::reno 119.49 39.3) (tools::san-francisco 122.26 37.47) (tools::tampa 82.27 27.57) (tools::victoria 123.21 48.25) (tools::wilmington 77.57 34.14)) (defparameter tools::*cities*) (#2# . 21911) tools::find-all-if remove-if-not tools::neighbors (defun tools::neighbors) (#2# . 22612) (tools::city) tools::c tools::air-distance #Y(nil nil nil (24 45 474 26 13 0 10 1 17 146 76 73 39 14 13 0 13 1 19 2 475 12 9 1000 19 2 272 29) #1# #2# 22612) #Y(tools::neighbors nil nil (24 45 444 26 34 476 12 14 464 19 2 468 29) #1# #2# 22612) "Find all cities within 1000 km." (defun tools::city) (#2# . 22802) (tools::name) tools::name #Y(tools::city nil nil (24 45 482 26 13 0 14 464 19 2 97 29) #1# #2# 22802) "Find the city with this name." tools::trip% (defun tools::trip%) (#2# . 22881) (tools::start tools::dest) tools::dest #Y(nil nil nil (24 45 474 26 13 0 13 1 19 2 475 29) #1# #2# 22881) #Y(tools::trip% nil nil (24 45 255 24 45 489 26 13 1 13 0 19 1 364 12 33 470 12 34 490 12 9 1 19 5 434 29) #1# #2# 22881) "Search for a way from the start to dest." tools::path "PATH-" (tools::state (tools::previous nil) (tools::cost-so-far 0) (tools::total-cost 0)) ((tools::state nil t nil 0 nil) (tools::previous nil t nil 1 nil) (tools::cost-so-far 0 t nil 2 nil) (tools::total-cost 0 t nil 3 nil)) tools::copy-path tools::print-path (tools::make-path) tools::path-p #9=(tools::path (:print-function tools::print-path)) (defstruct #9#) (#2# . 23055) tools::make-path (defun tools::make-path) (#2# . 23055) (&key #10=#:state #11=#:previous (#12=#:cost-so-far 0) (#13=#:total-cost 0)) (nil :total-cost :cost-so-far :previous :state) #10# #11# #12# #13# 0 si::make-structure #Y(tools::make-path nil nil (28 508 22 40 2 77 46 509 22 40 2 77 46 510 22 40 3 9 0 46 511 22 40 3 9 0 46 512 15 513 13 3 13 2 13 1 13 0 19 5 514 29) #1# #2# 23055) find-class tools::path-total-cost symbol-package package ext::package-locked-p si::*ignore-package-locks* package-error "Ignore lock and proceed." "Attempt to define CAS accessor ~S in locked package." (tools::path-total-cost) :package si::signal-simple-error mp::cas-expander #:g303 si::x gensym si::new si::old mp::compare-and-swap-structure quote si::structure-ref #Y(nil nil nil (24 45 529 24 45 530 26 19 0 531 12 19 0 531 12 46 532 46 533 77 77 13 0 13 1 15 534 13 2 15 535 1 493 6 2 12 9 3 13 0 10 1 6 6 12 15 536 13 2 15 535 1 493 6 2 12 8 3 6 4 12 72 6 43 2 29) #1# #2# 23055) si::put-sysprop tools::path-cost-so-far (tools::path-cost-so-far) #:g304 #Y(nil nil nil (24 45 541 24 45 530 26 19 0 531 12 19 0 531 12 46 532 46 533 77 77 13 0 13 1 15 534 13 2 15 535 1 493 6 2 12 9 2 13 0 10 1 6 6 12 15 536 13 2 15 535 1 493 6 2 12 8 2 6 4 12 72 6 43 2 29) #1# #2# 23055) tools::path-previous (tools::path-previous) #:g305 #Y(nil nil nil (24 45 545 24 45 530 26 19 0 531 12 19 0 531 12 46 532 46 533 77 77 13 0 13 1 15 534 13 2 15 535 1 493 6 2 12 9 1 13 0 10 1 6 6 12 15 536 13 2 15 535 1 493 6 2 12 8 1 6 4 12 72 6 43 2 29) #1# #2# 23055) tools::path-state (tools::path-state) #:g306 #Y(nil nil nil (24 45 549 24 45 530 26 19 0 531 12 19 0 531 12 46 532 46 533 77 77 13 0 13 1 15 534 13 2 15 535 1 493 6 2 12 9 0 13 0 10 1 6 6 12 15 536 13 2 15 535 1 493 6 2 12 8 0 6 4 12 72 6 43 2 29) #1# #2# 23055) tools::trip (defun tools::trip) (#2# . 23470) (tools::start tools::dest &optional (tools::beam-width 1)) :state #Y(nil nil nil (24 45 474 26 13 0 13 2 19 2 475 29) #1# #2# 23470) tools::path-saver #Y(tools::trip nil nil (24 45 255 24 45 489 25 40 3 9 1 46 438 26 14 555 13 2 19 2 504 12 13 1 14 413 33 547 12 19 3 364 12 33 470 12 33 475 12 34 556 12 19 3 557 12 33 517 12 13 0 19 5 434 29) #1# #2# 23470) "Search for the best path from start to
  dest." tools::+earth-diameter+ 12765.0 "Diameter of planet earth in km." (defconstant tools::+earth-diameter+) (#2# . 23906) (defun tools::air-distance) (#2# . 23984) (tools::city1 tools::city2) tools::city1 tools::city2 tools::xyz-coords tools::distance tools::d tools::earth-diameter / asin #Y(tools::air-distance nil nil (24 45 568 24 45 569 26 13 1 19 1 570 12 13 0 19 1 570 12 19 2 571 45 572 14 573 13 0 9 2 19 2 574 16 575 12 19 2 361 43 1 29) #1# #2# 23984) "The great-circle distance between two
  cities." (defun tools::xyz-coords) (#2# . 24204) (tools::city) tools::city-lat tools::deg->radians tools::city-long tools::phi tools::psi cos sin #Y(tools::xyz-coords nil nil (24 45 444 26 13 0 19 1 581 12 19 1 582 12 13 0 19 1 583 12 19 1 582 12 46 584 46 585 10 0 16 586 12 10 1 16 586 12 19 2 361 12 10 0 16 586 12 10 1 16 587 12 19 2 361 12 10 0 16 587 6 3 73 43 2 29) #1# #2# 24204) "Returns the x,y,z coords of a point
  on a sphere. The center is (0 0 0)
  and the north pole is (0 0 1)." (defun tools::distance) (#2# . 24518) (tools::point1 tools::point2) tools::point1 tools::point2 tools::a tools::b expt #Y(nil nil nil (24 45 595 24 45 596 26 13 1 13 0 19 2 401 12 8 2 17 597 29) #1# #2# 24518) reduce sqrt #Y(tools::distance nil nil (24 45 593 24 45 594 26 33 64 12 1 598 12 13 1 13 0 19 3 289 12 19 2 599 16 600 29) #1# #2# 24518) "The Euclidean distance between two
  points in n-dimensional space." (defun tools::deg->radians) (#2# . 24743) (tools::deg) tools::deg truncate rem 5/3 pi 1/180 #Y(tools::deg->radians nil nil (24 45 606 26 13 0 19 1 607 12 13 0 8 1 17 608 12 15 609 19 2 361 12 19 2 64 12 14 610 15 611 19 3 361 29) #1# #2# 24743) "Convert degrees and minutes to radians." (defun tools::is) (#2# . 24889) (tools::value &key (tools::key (function identity)) (tools::test (function eql))) (nil :test :key) identity tools::key tools::test #Y(nil nil nil (24 45 493 26 13 1 13 3 13 2 13 0 20 1 23 12 20 2 23 29) #1# #2# 24889) #Y(tools::is nil nil (24 45 368 28 617 22 40 4 33 618 12 46 619 22 40 4 33 88 12 46 620 34 621 73 29) #1# #2# 24889) "Returns a predicate that tests for a 
  given value." (defun tools::path-saver) (#2# . 25116) (tools::successors tools::cost-fn tools::cost-left-fn) tools::cost-left-fn tools::old-path tools::old-state tools::new-state tools::old-cost :previous :cost-so-far :total-cost #Y(nil nil nil (24 45 630 26 13 2 19 1 539 12 13 4 13 1 13 0 20 2 23 12 19 2 64 45 631 14 555 13 1 14 632 13 3 14 633 13 3 14 634 13 0 13 4 13 1 20 1 23 12 19 2 64 12 19 8 504 43 1 29) #1# #2# 25116) #Y(nil nil nil (24 45 628 26 13 0 19 1 547 45 629 34 635 12 13 4 13 0 20 1 23 12 19 2 289 43 1 29) #1# #2# 25116) #Y(tools::path-saver nil nil (24 45 343 24 45 410 24 45 627 26 34 636 73 29) #1# #2# 25116) "Returns a function that will take 
  a path as an arg and generate 
  successor paths, including costs." (defun tools::print-path) (#2# . 25987) (tools::path &optional (stream t) tools::depth) tools::depth "#<Path to ~A cost ~,1F>" #Y(tools::print-path nil nil (24 45 493 25 40 3 14 19 46 24 25 40 2 77 46 642 26 13 1 15 643 13 2 19 1 547 12 13 2 19 1 517 12 19 4 50 29) #1# #2# 25987) tools::show-city-path (defun tools::show-city-path) (#2# . 26182) (tools::path &optional (stream t)) "#<Path ~,1F km: ~{~:(~A~)~^ - ~}>" tools::city-name tools::map-path reverse #Y(tools::show-city-path nil nil (24 45 493 25 40 3 14 19 46 24 26 13 0 15 649 13 1 19 1 517 12 33 650 12 13 1 19 2 651 16 652 12 19 4 50 0 29) #1# #2# 26182) "Show the length of a path, and the 
  cities on it." (defun tools::map-path) (#2# . 26437) (tools::fn tools::path) tools::fn #Y(tools::map-path nil nil (24 45 658 24 45 493 26 10 0 76 39 5 75 73 38 26 13 1 13 0 19 1 547 12 20 1 23 12 13 1 13 0 19 1 543 12 19 2 651 3 73 29) #1# #2# 26437) "Call fn on each state in the path,
  collecting results." tools::iter-wide-search (defun tools::iter-wide-search) (#2# . 26660) (tools::start tools::goalp tools::successors tools::cost-fn &key (tools::width 1) (max 100)) (nil :max :width) tools::width max "; Width: ~D" :width :max #Y(tools::iter-wide-search nil nil (24 45 255 24 45 342 24 45 343 24 45 410 28 665 22 40 3 9 1 46 666 22 40 3 9 100 46 667 14 345 15 668 13 1 19 3 347 13 1 13 0 19 2 391 76 73 39 39 13 5 13 4 13 3 13 2 13 1 19 5 434 73 40 23 13 5 13 4 13 3 13 2 14 669 10 1 16 261 12 14 670 13 0 19 8 661 29) #1# #2# 26660) "Search, increasing beam-width from
  width to max." tools::graph-search% (defun tools::graph-search%) (#2# . 27704) (tools::states tools::goalp tools::successors tools::combiner &optional (tools::state= (function eql)) tools::old-states) tools::state= tools::old-states "~&;; Search: ~A" tools::new-states adjoin tools::graph-search #Y(tools::graph-search% nil nil (24 45 341 24 45 342 24 45 343 24 45 344 25 40 4 33 88 12 46 677 25 40 2 77 46 678 26 14 345 15 679 13 5 19 3 347 10 5 76 39 6 11 68 73 38 65 13 4 10 5 4 12 20 1 23 39 7 10 5 4 73 38 48 13 2 13 5 13 3 13 1 13 0 19 4 680 12 10 5 5 12 20 2 23 12 13 4 13 3 13 2 13 1 10 5 4 12 13 0 14 42 13 1 19 4 681 12 19 6 682 29) #1# #2# 27704) "Find a state that satisfies goalp. 
  Start with states, and search according
  to successors and combiner. Don't
  try the same state twice." tools::new-states% (defun tools::new-states%) (#2# . 28739) (tools::states tools::successors tools::state= tools::old-states) tools::state #Y(nil nil nil (24 45 689 26 13 0 13 4 14 42 13 2 19 4 44 73 40 12 13 0 13 1 14 42 13 2 19 4 44 29) #1# #2# 28739) #Y(tools::new-states% nil nil (24 45 341 24 45 343 24 45 677 24 45 678 26 34 690 12 13 2 10 3 4 12 20 1 23 12 19 2 393 29) #1# #2# 28739) "Generate successor states that have not
  been seen before." tools::rm-tmps (defun tools::rm-tmps) (#2# . 29088) "rm quicklisp/local-projects/paip/*tmp*" qml::shell tools::ok #Y(tools::rm-tmps nil nil (26 15 696 19 1 697 1 698 73 29) #1# #2# 29088) "Remove files whose name contains
  ``tmp'' from this directory." tools::next2 (defun tools::next2) (#2# . 29242) (tools::x) #Y(tools::next2 nil nil (24 45 83 26 13 0 9 1 19 2 64 12 13 0 9 2 19 2 64 6 2 73 29) #1# #2# 29242) "Given a number x, returns the list
  (x+1, x+2). Used to demonstrate the 
  difference between tree-search and 
  graph search." tools::a*-search% (defun tools::a*-search%) (#2# . 29420) (tools::paths tools::goalp tools::successors tools::cost-fn tools::cost-left-fn &optional (tools::state= (function eql)) tools::old-paths) tools::paths tools::old-paths ";;  Search: ~A" #:g321 tools::insert-path tools::state2 tools::cost tools::cost2 tools::path2 tools::find-path tools::better-path delete tools::a*-search #Y(tools::a*-search% nil nil (24 45 711 24 45 342 24 45 343 24 45 410 24 45 627 25 40 4 33 88 12 46 677 25 40 2 77 46 712 26 14 345 15 713 13 6 19 3 347 10 6 76 39 6 11 68 73 38 264 13 5 10 6 4 12 19 1 547 12 20 1 23 39 11 10 6 4 12 13 6 72 2 38 239 10 6 45 714 10 0 4 12 10 0 5 51 0 10 0 51 7 22 43 1 45 493 13 0 19 1 547 45 689 13 1 13 2 19 2 715 51 2 13 6 13 0 20 1 23 45 40 38 165 10 0 4 45 716 13 3 19 1 539 12 13 7 13 2 13 0 20 2 23 12 19 2 64 45 717 13 7 13 1 20 1 23 45 718 14 555 13 2 14 632 13 5 14 633 13 1 14 634 13 1 13 0 19 2 64 12 19 8 504 45 719 75 45 412 13 4 13 14 13 9 19 3 720 51 0 39 27 13 1 13 0 19 2 721 39 16 13 1 13 0 13 14 19 2 722 12 19 2 715 51 14 38 52 13 4 13 8 13 9 19 3 720 51 0 39 30 13 1 13 0 19 2 721 39 19 13 1 13 14 19 2 715 51 14 13 0 13 8 19 2 722 51 8 38 10 13 1 13 14 19 2 715 51 14 43 4 10 1 5 51 1 43 1 10 0 40 -167 43 1 13 8 13 7 13 6 13 5 13 4 13 3 13 2 19 7 723 43 2 29) #1# #2# 29420) "Find a path whose state satisfies
  goalp. Start with paths, and expand
  successors, exploring least cost first.
  When there are duplicate states, keep
  the one with the lower cost and 
  discard the other." tools::find-path% (defun tools::find-path%) (#2# . 32558) (tools::state tools::paths tools::state=) find #Y(tools::find-path% nil nil (24 45 689 24 45 711 24 45 677 26 13 2 13 1 14 413 33 547 12 14 42 13 0 19 6 730 29) #1# #2# 32558) "Find the path with this state among
  the list of paths." (defun tools::better-path) (#2# . 32734) (tools::path1 tools::path2) tools::path1 #Y(tools::better-path nil nil (24 45 736 24 45 719 26 13 1 19 1 517 12 13 0 19 1 517 12 19 2 272 29) #1# #2# 32734) "Is path1 cheaper than path2?" tools::insert-path% (defun tools::insert-path%) (#2# . 32861) (tools::path tools::paths) merge #Y(tools::insert-path% nil nil (24 45 493 24 45 711 26 15 446 10 1 6 1 12 13 0 33 272 12 14 413 33 517 12 19 6 743 29) #1# #2# 32861) "Put path into the right position, 
  sorted by total cost." tools::path-states (defun tools::path-states) (#2# . 33041) (tools::path) #Y(tools::path-states nil nil (24 45 493 26 10 0 73 39 18 13 0 19 1 547 12 13 0 19 1 543 12 19 1 746 3 73 29) #1# #2# 33041) "Collect the states along this path." tools::search-all (defun tools::search-all) (#2# . 33200) (tools::start tools::goalp tools::successors tools::cost-fn tools::beam-width) tools::solutions #Y(nil nil nil (24 45 83 26 13 5 13 0 20 1 23 39 8 13 0 10 1 3 51 1 75 73 29) #1# #2# 33200) nreverse #Y(tools::search-all nil nil (24 45 255 24 45 342 24 45 343 24 45 410 24 45 438 26 75 45 756 13 5 34 757 12 13 3 13 2 13 1 19 5 434 10 0 16 758 43 1 29) #1# #2# 33200) "Find all solutions to a problem using
  beam search. Can lead to an infinite 
  loop." (defun tools::sorter) (#2# . 34335) (tools::cost-fn) #Y(nil nil nil (24 45 412 24 45 411 26 15 446 13 0 33 272 12 14 413 13 2 19 4 414 12 13 1 33 272 12 14 413 13 2 19 6 743 29) #1# #2# 34335) #Y(tools::sorter nil nil (24 45 410 26 34 764 73 29) #1# #2# 34335) "Return a combiner function that sorts
  according to cost-fn." (defun tools::graph-search) (#2# . 38018) (tools::states tools::goalp tools::successor tools::combiner &optional (tools::state= (function eql)) (tools::old-states (make-hash-table :test tools::state=))) tools::successor make-hash-table si::hash-set #Y(tools::graph-search nil nil (24 45 341 24 45 342 24 45 770 24 45 344 25 40 4 33 88 12 46 677 25 40 9 14 42 13 0 19 2 771 12 46 678 26 10 5 76 39 6 11 68 73 38 62 13 4 10 5 4 12 20 1 23 39 7 10 5 4 73 38 45 13 2 13 5 14 343 13 1 13 0 19 4 680 12 10 5 5 12 20 2 23 12 13 4 14 343 13 2 10 5 4 12 13 0 14 19 19 3 772 13 0 19 5 682 29) #1# #2# 38018) "Find a state that satisfies goalp. 
  Start with states, and search according
  to successors and combiner. Don't
  try the same state twice." (defun tools::new-states) (#2# . 38956) (tools::states tools::successors tools::state= tools::old-states) gethash #Y(nil nil nil (24 45 689 26 13 0 13 4 14 42 13 2 19 4 44 73 40 8 13 0 13 1 19 2 778 29) #1# #2# 38956) #Y(tools::new-states nil nil (24 45 341 24 45 343 24 45 677 24 45 678 26 34 779 12 13 2 10 3 4 12 20 1 23 12 19 2 393 29) #1# #2# 38956) "Generate successor states that have not
  been seen before." (defun tools::a*-search) (#2# . 39259) (tools::paths tools::goalp tools::successors tools::cost-fn tools::cost-left-fn &optional (tools::state= (function eql)) (tools::test (function eql)) (tools::old-states (make-hash-table :test tools::test))) #:g353 tools::old2 remhash #Y(tools::a*-search nil nil (24 45 711 24 45 342 24 45 343 24 45 410 24 45 627 25 40 4 33 88 12 46 677 25 40 4 33 88 12 46 620 25 40 9 14 42 13 0 19 2 771 12 46 678 26 10 7 76 39 6 11 68 73 38 226 13 6 10 7 4 12 19 1 547 12 20 1 23 39 11 10 7 4 12 13 7 72 2 38 201 10 7 45 785 10 0 4 12 10 0 5 51 0 10 0 51 8 22 43 1 45 493 13 0 19 1 547 45 689 13 1 14 712 19 2 715 52 712 13 7 13 0 20 1 23 45 40 38 125 10 0 4 45 716 13 3 19 1 539 12 13 8 13 2 13 0 20 2 23 12 19 2 64 45 717 13 8 13 1 20 1 23 45 718 14 555 13 2 14 632 13 5 14 633 13 1 14 634 13 1 13 0 19 2 64 12 19 8 504 45 719 75 45 786 13 4 14 712 13 10 19 3 720 52 412 39 29 13 1 14 412 19 2 721 39 18 13 1 13 15 19 2 715 51 15 14 412 11 712 17 787 52 712 38 10 13 1 13 15 19 2 715 51 15 43 4 10 1 5 51 1 43 1 10 0 40 -127 43 1 13 9 13 8 13 7 13 6 13 5 13 4 13 3 14 712 19 8 723 43 2 29) #1# #2# 39259) "Find a path whose state satisfies
  goalp. Start with paths, and expand
  successors, exploring least cost first.
  When there are duplicate states, keep
  the one with the lower cost and 
  discard the other." (defun tools::insert-path) (#2# . 41253) (tools::path tools::paths) #:g367 typep hash-table (list hash-table) si::etypecase-error #Y(tools::insert-path nil nil (24 45 493 24 45 711 26 10 0 45 793 13 0 15 446 19 2 794 39 23 15 446 10 2 6 1 12 13 1 33 272 12 14 413 33 517 12 19 6 743 38 27 13 0 15 795 19 2 794 39 12 13 2 13 1 14 19 19 3 772 38 7 13 0 1 796 17 797 43 1 29) #1# #2# 41253) "Put path into the right position, 
  sorted by total cost." (defun tools::find-path) (#2# . 41547) (tools::state tools::paths tools::state=) #:g382 #:g385 #:loop-hashtab-383 #:loop-it-386 si::hash-table-iterator #:loop-hashtab-next-384 #:loop-hash-val-temp-387 #:loop-hash-key-temp-388 #:loop-hash-predicate-var-389 (list hash-table) #Y(tools::find-path nil nil (24 45 689 24 45 711 24 45 677 26 10 1 45 803 13 0 15 446 19 2 794 39 19 13 3 13 2 14 413 33 547 12 14 42 13 1 19 6 730 38 113 13 0 15 795 19 2 794 39 98 58 60 93 77 77 13 3 77 46 804 46 805 46 493 46 806 10 2 16 807 45 808 57 27 61 2 2 61 13 1 20 0 23 47 2 809 47 1 810 45 811 10 0 39 9 10 2 51 8 10 1 51 6 10 0 51 5 43 3 76 39 4 35 0 1 13 8 13 10 13 3 19 1 547 12 20 2 23 39 6 10 3 73 36 6 35 0 0 62 73 43 1 43 4 63 38 7 13 0 1 812 17 797 43 1 29) #1# #2# 41547) "Find the path with this state among
    the list of paths." tools::trace-all (defmacro tools::trace-all) (#2# . 42032) (&optional (package *package*)) #:g394 #:g393 #:g395 *package* si::dm-too-many-arguments "FN-LIST" tools::temp-fns tools::fns #:loop-pkgsym-429 tools::sym #:loop-it-431 (:internal :external) si::packages-iterator #:loop-pkgsym-next-430 fboundp let handler-case trace (warning nil nil) #Y(tools::trace-all nil nil (24 45 819 24 45 820 26 10 1 5 45 821 10 0 39 13 10 0 4 12 10 0 5 51 0 22 38 3 11 822 45 519 10 1 39 6 13 3 19 1 823 15 824 19 1 531 12 77 46 825 46 826 77 77 13 2 46 827 46 828 46 829 13 2 15 830 14 19 19 3 831 45 832 57 27 61 2 2 33 13 1 20 0 23 51 2 55 3 1 76 39 4 35 0 1 10 3 16 833 39 8 13 3 10 6 3 51 6 35 0 0 62 43 1 43 3 15 834 13 0 10 1 6 2 6 1 12 15 835 15 836 10 0 7 2 12 1 837 6 3 6 3 73 43 2 29) #1# #2# 42032) "Trace all user-created functions. 
  Optional arg ``package'', which
  defaults to *package*, specifies
  the package to trace.")) #2# 0) #Y(si::bytecodes nil nil (1 2 16 3 1 2 52 2 15 2 15 4 15 5 15 6 19 4 7 1 2 73 29) #1# #2# 127) #Y(si::bytecodes nil nil (1 8 16 3 1 8 52 8 15 8 15 4 15 9 15 10 19 4 7 1 8 73 29) #1# #2# 163) #Y(si::bytecodes nil nil (15 11 15 4 15 12 15 13 19 4 7 15 11 14 14 77 15 15 19 4 7 15 11 34 51 12 19 2 52 15 11 15 53 15 54 19 3 55 1 11 73 29) #1# #2# 186) #Y(si::bytecodes nil nil (15 56 15 4 15 57 15 58 19 4 7 15 56 14 14 77 15 59 19 4 7 15 56 34 66 12 19 2 52 15 56 15 53 15 67 19 3 55 1 56 73 29) #1# #2# 2164) #Y(si::bytecodes nil nil (15 68 75 17 69 15 68 15 70 15 71 19 3 55 15 68 15 4 15 72 15 73 19 4 7 1 68 73 29) #1# #2# 2390) #Y(si::bytecodes nil nil (15 74 1 75 17 69 15 74 15 70 15 76 19 3 55 15 74 15 4 15 77 15 78 19 4 7 1 74 73 29) #1# #2# 3924) #Y(si::bytecodes nil nil (15 79 15 4 15 80 15 81 19 4 7 15 79 14 14 77 15 82 19 4 7 15 79 1 89 12 19 2 52 15 79 15 53 15 90 19 3 55 1 79 73 29) #1# #2# 4018) #Y(si::bytecodes nil nil (15 91 15 4 15 92 15 93 19 4 7 15 91 14 14 77 15 94 19 4 7 15 91 1 98 12 19 2 52 15 91 15 53 15 99 19 3 55 1 91 73 29) #1# #2# 4199) #Y(si::bytecodes nil nil (15 100 15 4 15 101 15 102 19 4 7 15 100 14 14 77 15 103 19 4 7 15 100 1 105 12 19 2 52 15 100 15 53 15 106 19 3 55 1 100 73 29) #1# #2# 4317) #Y(si::bytecodes nil nil (15 107 15 4 15 108 15 109 19 4 7 15 107 14 14 77 15 110 19 4 7 15 107 1 111 12 19 2 52 15 107 15 53 15 112 19 3 55 1 107 73 29) #1# #2# 4413) #Y(si::bytecodes nil nil (15 113 15 4 15 114 15 115 19 4 7 15 113 14 14 77 15 116 19 4 7 15 113 1 118 12 19 2 52 1 113 73 29) #1# #2# 4506) #Y(si::bytecodes nil nil (15 119 15 4 15 120 15 121 19 4 7 15 119 14 14 77 15 122 19 4 7 15 119 1 123 12 19 2 52 15 119 15 53 15 124 19 3 55 1 119 73 29) #1# #2# 4555) #Y(si::bytecodes nil nil (15 125 15 4 15 126 15 127 19 4 7 15 125 14 14 77 15 128 19 4 7 15 125 1 130 12 19 2 52 15 125 15 53 15 131 19 3 55 1 125 73 29) #1# #2# 4685) #Y(si::bytecodes nil nil (15 132 15 4 15 133 15 134 19 4 7 15 132 14 14 77 15 135 19 4 7 15 132 1 138 12 19 2 52 15 132 15 53 15 139 19 3 55 1 132 73 29) #1# #2# 4967) #Y(si::bytecodes nil nil (15 140 15 4 15 141 15 142 19 4 7 15 140 14 14 77 15 143 19 4 7 15 140 1 156 12 19 2 52 15 140 15 53 15 157 19 3 55 1 140 73 29) #1# #2# 5301) #Y(si::bytecodes nil nil (1 158 45 159 1 160 45 161 1 162 45 163 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 6581) #Y(si::bytecodes nil nil (1 165 45 166 1 160 45 167 1 168 45 169 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 6734) #Y(si::bytecodes nil nil (1 170 45 171 1 160 45 172 1 173 45 174 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 6776) #Y(si::bytecodes nil nil (1 175 45 176 1 160 45 177 1 178 45 179 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 6820) #Y(si::bytecodes nil nil (1 180 45 181 1 182 45 183 1 182 45 184 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 6864) #Y(si::bytecodes nil nil (1 185 45 186 1 182 45 187 1 188 45 189 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 6911) #Y(si::bytecodes nil nil (1 190 45 191 1 182 45 192 1 193 45 194 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 6966) #Y(si::bytecodes nil nil (1 195 45 196 1 182 45 197 1 198 45 199 13 2 13 0 13 1 19 3 164 43 1 43 2 29) #1# #2# 7021) #Y(si::bytecodes nil nil (15 152 15 4 15 200 15 201 19 4 7 15 152 14 14 77 15 202 19 4 7 15 152 1 204 12 19 2 52 15 152 15 53 15 205 19 3 55 1 152 73 29) #1# #2# 7070) #Y(si::bytecodes nil nil (15 154 15 4 15 206 15 207 19 4 7 15 154 14 14 77 15 208 19 4 7 15 154 1 210 12 19 2 52 15 154 15 53 15 211 19 3 55 1 154 73 29) #1# #2# 7330) #Y(si::bytecodes nil nil (15 153 15 4 15 212 15 213 19 4 7 15 153 14 14 77 15 214 19 4 7 15 153 1 215 12 19 2 52 15 153 15 53 15 216 19 3 55 1 153 73 29) #1# #2# 7533) #Y(si::bytecodes nil nil (15 155 15 4 15 217 15 218 19 4 7 15 155 14 14 77 15 219 19 4 7 15 155 1 220 12 19 2 52 15 155 15 53 15 221 19 3 55 1 155 73 29) #1# #2# 7795) #Y(si::bytecodes nil nil (15 203 15 4 15 222 15 223 19 4 7 15 203 14 14 77 15 224 19 4 7 15 203 1 226 12 19 2 52 15 203 15 53 15 227 19 3 55 1 203 73 29) #1# #2# 8013) #Y(si::bytecodes nil nil (15 209 15 4 15 228 15 229 19 4 7 15 209 14 14 77 15 230 19 4 7 15 209 1 231 12 19 2 52 15 209 15 53 15 232 19 3 55 1 209 73 29) #1# #2# 8167) #Y(si::bytecodes nil nil (15 162 15 4 15 233 15 234 19 4 7 15 162 14 14 77 15 235 19 4 7 15 162 1 239 12 19 2 52 15 162 15 53 15 240 19 3 55 1 162 73 29) #1# #2# 8318) #Y(si::bytecodes nil nil (15 173 15 4 15 241 15 242 19 4 7 15 173 14 14 77 15 243 19 4 7 15 173 1 245 12 19 2 52 15 173 15 53 15 246 19 3 55 1 173 73 29) #1# #2# 8736) #Y(si::bytecodes nil nil (15 168 15 4 15 247 15 248 19 4 7 15 168 14 14 77 15 249 19 4 7 15 168 1 250 12 19 2 52 15 168 15 53 15 251 19 3 55 1 168 73 29) #1# #2# 9069) #Y(si::bytecodes nil nil (15 182 15 4 15 252 15 253 19 4 7 15 182 14 14 77 15 254 19 4 7 15 182 1 262 12 19 2 52 15 182 15 53 15 263 19 3 55 1 182 73 29) #1# #2# 9546) #Y(si::bytecodes nil nil (15 257 15 4 15 264 15 265 19 4 7 15 257 14 14 77 15 266 19 4 7 15 257 1 273 12 19 2 52 15 257 15 53 15 274 19 3 55 1 257 73 29) #1# #2# 10743) #Y(si::bytecodes nil nil (15 188 15 4 15 275 15 276 19 4 7 15 188 14 14 77 15 277 19 4 7 15 188 1 278 12 19 2 52 15 188 15 53 15 279 19 3 55 1 188 73 29) #1# #2# 11137) #Y(si::bytecodes nil nil (15 193 15 4 15 280 15 281 19 4 7 15 193 14 14 77 15 282 19 4 7 15 193 1 283 12 19 2 52 15 193 15 53 15 284 19 3 55 1 193 73 29) #1# #2# 11949) #Y(si::bytecodes nil nil (15 198 15 4 15 285 15 286 19 4 7 15 198 14 14 77 15 287 19 4 7 15 198 1 292 12 19 2 52 15 198 15 53 15 293 19 3 55 1 198 73 29) #1# #2# 12211) #Y(si::bytecodes nil nil (15 148 15 4 15 294 15 295 19 4 7 15 148 14 14 77 15 296 19 4 7 15 148 1 297 12 19 2 52 1 148 73 29) #1# #2# 12531) #Y(si::bytecodes nil nil (15 298 15 4 15 299 15 300 19 4 7 15 298 14 14 77 15 301 19 4 7 15 298 1 308 12 19 2 52 15 298 15 53 15 309 19 3 55 1 298 73 29) #1# #2# 13423) #Y(si::bytecodes nil nil (15 305 15 4 15 310 15 311 19 4 7 15 305 14 14 77 15 312 19 4 7 15 305 34 316 12 19 2 52 15 305 15 53 15 317 19 3 55 1 305 73 29) #1# #2# 14276) #Y(si::bytecodes nil nil (15 318 15 4 15 319 15 320 19 4 7 15 318 14 14 77 15 321 19 4 7 15 318 34 335 12 19 2 52 15 318 15 53 15 336 19 3 55 1 318 73 29) #1# #2# 15005) #Y(si::bytecodes nil nil (15 337 15 4 15 338 15 339 19 4 7 15 337 14 14 77 15 340 19 4 7 15 337 1 348 12 19 2 52 15 337 15 53 15 349 19 3 55 1 337 73 29) #1# #2# 16012) #Y(si::bytecodes nil nil (15 350 15 4 15 351 15 352 19 4 7 15 350 14 14 77 15 353 19 4 7 15 350 1 355 12 19 2 52 15 350 15 53 15 356 19 3 55 1 350 73 29) #1# #2# 17147) #Y(si::bytecodes nil nil (15 357 15 4 15 358 15 359 19 4 7 15 357 14 14 77 15 360 19 4 7 15 357 1 362 12 19 2 52 15 357 15 53 15 363 19 3 55 1 357 73 29) #1# #2# 17334) #Y(si::bytecodes nil nil (15 364 15 4 15 365 15 366 19 4 7 15 364 14 14 77 15 367 19 4 7 15 364 34 370 12 19 2 52 15 364 15 53 15 371 19 3 55 1 364 73 29) #1# #2# 17607) #Y(si::bytecodes nil nil (15 372 15 4 15 373 15 374 19 4 7 15 372 14 14 77 15 375 19 4 7 15 372 1 377 12 19 2 52 15 372 15 53 15 378 19 3 55 1 372 73 29) #1# #2# 18015) #Y(si::bytecodes nil nil (15 379 15 4 15 380 15 381 19 4 7 15 379 14 14 77 15 382 19 4 7 15 379 1 383 12 19 2 52 15 379 15 53 15 384 19 3 55 1 379 73 29) #1# #2# 18408) #Y(si::bytecodes nil nil (15 385 15 4 15 386 15 387 19 4 7 15 385 14 14 77 15 388 19 4 7 15 385 34 395 12 19 2 52 15 385 15 53 15 396 19 3 55 1 385 73 29) #1# #2# 18589) #Y(si::bytecodes nil nil (15 397 15 4 15 398 15 399 19 4 7 15 397 14 14 77 15 400 19 4 7 15 397 34 404 12 19 2 52 15 397 15 53 15 405 19 3 55 1 397 73 29) #1# #2# 19317) #Y(si::bytecodes nil nil (15 406 15 4 15 407 15 408 19 4 7 15 406 14 14 77 15 409 19 4 7 15 406 34 416 12 19 2 52 15 406 15 53 15 417 19 3 55 1 406 73 29) #1# #2# 19720) #Y(si::bytecodes nil nil (15 418 15 4 15 419 15 420 19 4 7 15 418 14 14 77 15 421 19 4 7 15 418 1 423 12 19 2 52 15 418 15 53 15 424 19 3 55 1 418 73 29) #1# #2# 19911) #Y(si::bytecodes nil nil (15 425 15 4 15 426 15 427 19 4 7 15 425 14 14 77 15 428 19 4 7 15 425 34 432 12 19 2 52 15 425 15 53 15 433 19 3 55 1 425 73 29) #1# #2# 20115) #Y(si::bytecodes nil nil (15 434 15 4 15 435 15 436 19 4 7 15 434 14 14 77 15 437 19 4 7 15 434 34 442 12 19 2 52 15 434 15 53 15 443 19 3 55 1 434 73 29) #1# #2# 20544) #Y(si::bytecodes nil nil (15 444 15 445 15 446 77 15 447 15 448 15 449 77 77 77 15 450 9 3 77 77 77 19 15 451 15 452 15 4 15 453 15 454 19 4 7 15 455 15 4 15 456 15 457 19 4 7 15 455 14 14 77 15 458 19 4 7 15 455 1 463 12 19 2 52 1 444 73 29) #1# #2# 21377) #Y(si::bytecodes nil nil (1 464 16 3 1 465 52 464 15 464 15 4 15 466 15 467 19 4 7 1 464 73 29) #1# #2# 21911) #Y(si::bytecodes nil nil (15 468 33 469 12 19 2 52 29) #1# #2# 22551) #Y(si::bytecodes nil nil (15 470 15 4 15 471 15 472 19 4 7 15 470 14 14 77 15 473 19 4 7 15 470 34 477 12 19 2 52 15 470 15 53 15 478 19 3 55 1 470 73 29) #1# #2# 22612) #Y(si::bytecodes nil nil (15 444 15 4 15 479 15 480 19 4 7 15 444 14 14 77 15 481 19 4 7 15 444 1 483 12 19 2 52 15 444 15 53 15 484 19 3 55 1 444 73 29) #1# #2# 22802) #Y(si::bytecodes nil nil (15 485 15 4 15 486 15 487 19 4 7 15 485 14 14 77 15 488 19 4 7 15 485 34 491 12 19 2 52 15 485 15 53 15 492 19 3 55 1 485 73 29) #1# #2# 22881) #Y(si::bytecodes nil nil (15 493 15 494 77 77 15 495 15 496 15 497 77 15 498 77 15 499 9 4 77 77 15 500 19 15 451 15 501 15 4 15 502 15 503 19 4 7 15 504 15 4 15 505 15 506 19 4 7 15 504 14 14 77 15 507 19 4 7 15 493 19 1 516 78 513 15 504 1 515 12 19 2 52 1 517 16 518 45 519 10 0 39 10 10 0 16 520 39 4 11 521 76 39 16 15 522 15 523 15 524 15 525 14 526 13 0 19 6 527 43 1 15 517 15 528 1 537 12 19 3 538 1 539 16 518 45 519 10 0 39 10 10 0 16 520 39 4 11 521 76 39 16 15 522 15 523 15 524 15 540 14 526 13 0 19 6 527 43 1 15 539 15 528 1 542 12 19 3 538 1 543 16 518 45 519 10 0 39 10 10 0 16 520 39 4 11 521 76 39 16 15 522 15 523 15 524 15 544 14 526 13 0 19 6 527 43 1 15 543 15 528 1 546 12 19 3 538 1 547 16 518 45 519 10 0 39 10 10 0 16 520 39 4 11 521 76 39 16 15 522 15 523 15 524 15 548 14 526 13 0 19 6 527 43 1 15 547 15 528 1 550 12 19 3 538 1 493 73 29) #1# #2# 23055) #Y(si::bytecodes nil nil (15 551 15 4 15 552 15 553 19 4 7 15 551 14 14 77 15 554 19 4 7 15 551 34 558 12 19 2 52 15 551 15 53 15 559 19 3 55 1 551 73 29) #1# #2# 23470) #Y(si::bytecodes nil nil (15 560 1 561 17 69 15 560 15 70 15 562 19 3 55 15 560 15 4 15 563 15 564 19 4 7 1 560 73 29) #1# #2# 23906) #Y(si::bytecodes nil nil (15 475 15 4 15 565 15 566 19 4 7 15 475 14 14 77 15 567 19 4 7 15 475 1 576 12 19 2 52 15 475 15 53 15 577 19 3 55 1 475 73 29) #1# #2# 23984) #Y(si::bytecodes nil nil (15 570 15 4 15 578 15 579 19 4 7 15 570 14 14 77 15 580 19 4 7 15 570 1 588 12 19 2 52 15 570 15 53 15 589 19 3 55 1 570 73 29) #1# #2# 24204) #Y(si::bytecodes nil nil (15 571 15 4 15 590 15 591 19 4 7 15 571 14 14 77 15 592 19 4 7 15 571 1 601 12 19 2 52 15 571 15 53 15 602 19 3 55 1 571 73 29) #1# #2# 24518) #Y(si::bytecodes nil nil (15 582 15 4 15 603 15 604 19 4 7 15 582 14 14 77 15 605 19 4 7 15 582 1 612 12 19 2 52 15 582 15 53 15 613 19 3 55 1 582 73 29) #1# #2# 24743) #Y(si::bytecodes nil nil (15 364 15 4 15 614 15 615 19 4 7 15 364 14 14 77 15 616 19 4 7 15 364 34 622 12 19 2 52 15 364 15 53 15 623 19 3 55 1 364 73 29) #1# #2# 24889) #Y(si::bytecodes nil nil (15 557 15 4 15 624 15 625 19 4 7 15 557 14 14 77 15 626 19 4 7 15 557 34 637 12 19 2 52 15 557 15 53 15 638 19 3 55 1 557 73 29) #1# #2# 25116) #Y(si::bytecodes nil nil (15 498 15 4 15 639 15 640 19 4 7 15 498 14 14 77 15 641 19 4 7 15 498 1 644 12 19 2 52 1 498 73 29) #1# #2# 25987) #Y(si::bytecodes nil nil (15 645 15 4 15 646 15 647 19 4 7 15 645 14 14 77 15 648 19 4 7 15 645 1 653 12 19 2 52 15 645 15 53 15 654 19 3 55 1 645 73 29) #1# #2# 26182) #Y(si::bytecodes nil nil (15 651 15 4 15 655 15 656 19 4 7 15 651 14 14 77 15 657 19 4 7 15 651 1 659 12 19 2 52 15 651 15 53 15 660 19 3 55 1 651 73 29) #1# #2# 26437) #Y(si::bytecodes nil nil (15 661 15 4 15 662 15 663 19 4 7 15 661 14 14 77 15 664 19 4 7 15 661 1 671 12 19 2 52 15 661 15 53 15 672 19 3 55 1 661 73 29) #1# #2# 26660) #Y(si::bytecodes nil nil (15 673 15 4 15 674 15 675 19 4 7 15 673 14 14 77 15 676 19 4 7 15 673 1 683 12 19 2 52 15 673 15 53 15 684 19 3 55 1 673 73 29) #1# #2# 27704) #Y(si::bytecodes nil nil (15 685 15 4 15 686 15 687 19 4 7 15 685 14 14 77 15 688 19 4 7 15 685 34 691 12 19 2 52 15 685 15 53 15 692 19 3 55 1 685 73 29) #1# #2# 28739) #Y(si::bytecodes nil nil (15 693 15 4 15 694 15 695 19 4 7 15 693 14 14 77 77 19 4 7 15 693 1 699 12 19 2 52 15 693 15 53 15 700 19 3 55 1 693 73 29) #1# #2# 29088) #Y(si::bytecodes nil nil (15 701 15 4 15 702 15 703 19 4 7 15 701 14 14 77 15 704 19 4 7 15 701 1 705 12 19 2 52 15 701 15 53 15 706 19 3 55 1 701 73 29) #1# #2# 29242) #Y(si::bytecodes nil nil (15 707 15 4 15 708 15 709 19 4 7 15 707 14 14 77 15 710 19 4 7 15 707 1 724 12 19 2 52 15 707 15 53 15 725 19 3 55 1 707 73 29) #1# #2# 29420) #Y(si::bytecodes nil nil (15 726 15 4 15 727 15 728 19 4 7 15 726 14 14 77 15 729 19 4 7 15 726 1 731 12 19 2 52 15 726 15 53 15 732 19 3 55 1 726 73 29) #1# #2# 32558) #Y(si::bytecodes nil nil (15 721 15 4 15 733 15 734 19 4 7 15 721 14 14 77 15 735 19 4 7 15 721 1 737 12 19 2 52 15 721 15 53 15 738 19 3 55 1 721 73 29) #1# #2# 32734) #Y(si::bytecodes nil nil (15 739 15 4 15 740 15 741 19 4 7 15 739 14 14 77 15 742 19 4 7 15 739 1 744 12 19 2 52 15 739 15 53 15 745 19 3 55 1 739 73 29) #1# #2# 32861) #Y(si::bytecodes nil nil (15 746 15 4 15 747 15 748 19 4 7 15 746 14 14 77 15 749 19 4 7 15 746 1 750 12 19 2 52 15 746 15 53 15 751 19 3 55 1 746 73 29) #1# #2# 33041) #Y(si::bytecodes nil nil (15 752 15 4 15 753 15 754 19 4 7 15 752 14 14 77 15 755 19 4 7 15 752 34 759 12 19 2 52 15 752 15 53 15 760 19 3 55 1 752 73 29) #1# #2# 33200) #Y(si::bytecodes nil nil (15 422 15 4 15 761 15 762 19 4 7 15 422 14 14 77 15 763 19 4 7 15 422 34 765 12 19 2 52 15 422 15 53 15 766 19 3 55 1 422 73 29) #1# #2# 34335) #Y(si::bytecodes nil nil (15 682 15 4 15 767 15 768 19 4 7 15 682 14 14 77 15 769 19 4 7 15 682 1 773 12 19 2 52 15 682 15 53 15 774 19 3 55 1 682 73 29) #1# #2# 38018) #Y(si::bytecodes nil nil (15 680 15 4 15 775 15 776 19 4 7 15 680 14 14 77 15 777 19 4 7 15 680 34 780 12 19 2 52 15 680 15 53 15 781 19 3 55 1 680 73 29) #1# #2# 38956) #Y(si::bytecodes nil nil (15 723 15 4 15 782 15 783 19 4 7 15 723 14 14 77 15 784 19 4 7 15 723 1 788 12 19 2 52 15 723 15 53 15 789 19 3 55 1 723 73 29) #1# #2# 39259) #Y(si::bytecodes nil nil (15 715 15 4 15 790 15 791 19 4 7 15 715 14 14 77 15 792 19 4 7 15 715 1 798 12 19 2 52 15 715 15 53 15 799 19 3 55 1 715 73 29) #1# #2# 41253) #Y(si::bytecodes nil nil (15 720 15 4 15 800 15 801 19 4 7 15 720 14 14 77 15 802 19 4 7 15 720 1 813 12 19 2 52 15 720 15 53 15 814 19 3 55 1 720 73 29) #1# #2# 41547) #Y(si::bytecodes nil nil (15 815 15 4 15 816 15 817 19 4 7 15 815 14 14 77 15 818 19 4 7 15 815 1 838 12 14 19 9 2 19 4 52 15 815 15 53 15 839 19 3 55 1 815 73 29) #1# #2# 42032))
